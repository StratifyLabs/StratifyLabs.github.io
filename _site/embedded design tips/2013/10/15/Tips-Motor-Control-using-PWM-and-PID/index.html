
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Motor Control using PWM and PID</title> 
<meta name="author" content="Stratify Labs, Inc">

<!-- Enable responsive viewport -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<!-- Le styles -->
<link href="/assets/themes/twitter/bootstrap3/css/bootstrap.min.css" rel="stylesheet">
<script src="/assets/themes/twitter/bootstrap3/js/jquery-2.0.3.min.js"></script>
<script src="/assets/themes/twitter/bootstrap3/js/bootstrap.min.js"></script>
<link href="/assets/themes/twitter/bootstrap3/css/font-awesome.min.css" rel="stylesheet">
<link href="/assets/themes/twitter/css/style.css" rel="stylesheet">
<link href="/assets/themes/twitter/css/syntax.css" rel="stylesheet">
<script src="/assets/themes/twitter/js/application.js"></script>

<!-- Le fav and touch icons -->
<!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

<!-- atom & rss feed -->
<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
<link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

</head>
<body style="min-height: 200px; padding-top: 50px;">
	<header class="navbar navbar-default navbar-fixed-top bs-docs-nav" role="banner">
		<div class="container">
			<div class="row">
				<div class="col-md-12">
					<div class="navbar-header">
						<button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".menu-navbar-collapse">
							<span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span>
						</button>
						<a class="navbar-brand" href="/index.html">
							<img style="height: 22px;" src="/images/StratifyOS-Logo.svg" />
						</a>
					</div>

					<!-- Collect the nav links, forms, and other content for toggling -->
					<div class="collapse navbar-collapse menu-navbar-collapse" role="navigation">
						<ul class="nav navbar-nav">
							<li><a href="https://github.com/StratifyLabs"><i class="fa fa-code-fork"></i> Code</a></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</header>

	<a class="anchor" id="top"></a>


	<div class="content" id="content">
		


<div class="container">
	<div class="row" style="margin-top: 20px;">
		<div class="col-md-offset-1 col-md-7">
			<div class="panel panel-default">
				<div class="panel-heading">
					<h1>
						Motor Control using PWM and PID <small>Embedded Design</small>
					</h1>
				</div>
				<div class="panel-body">
					<p><img class="post_image" src="/images/h-bridge.png" />
Bi-directional motor control can be done using an H-bridge circuit 
with pulse-width modulation (PWM) from a microcontroller to vary 
the speed. Several design challenges include preventing shoot-through, implementing 
a snubber circuit, as well as open and closed loop (such as PID) control 
mechanisms.</p>

<h2 id="pwm-control-of-an-h-bridge">PWM Control of an H-Bridge</h2>

<p>An H-bridge circuit consists of four transistors (usually two PMOS’s and two NMOS’s).  To maximize efficiency, the transistors are driven at a higher voltage than the microcontroller.  A typical H-bridge circuit with logic scaling circuitry is shown above.</p>

<p>Each side of the H-bridge has two transistors with the gates tied together resulting in complementary operation–Q3 is always off when Q1 is on and vice versa.  The same is true for Q2 and Q4.  The circuit works by setting PWMB to logic zero (Q2 on; Q4 off) and then setting PWMA to logic high (Q1 off; Q3 on).  The motor direction can be reversed by toggling PWMA and PWMB.</p>

<p>PWM is a simple way to vary the voltage applied to the motor. Most microcontrollers have dedicated PWM hardware, but an output compare timer can also generate a PWM signal.  PWM works by rapidly turning the motor on and off. For example, if the motor supply is 12V, the motor can be driven at 6V by applying a 50% duty cycle where half the time 12V is applied, and half the time 0V is applied as shown by the green signal in the plot below.</p>

<p><img class="post_image" src="/images/pwm-plot.jpg" /></p>

<p>While using PWM is simple, it introduces a problem called shoot-through which occurs when current flows directly from the power supply to ground when the transistors are being switched.  For example, when the PWMA input signal switches from high to low, Q1 turns on and Q3 turns off.  For a brief period of time, both Q1 and Q3 are partially on allowing current to flow from the supply to ground.  This causes efficiency to plummet and introduces heating problems in the transistors.  To overcome this problem additional circuitry must be added to ensure Q3 turns completely off before Q1 starts to turn on.</p>

<h3 id="preventing-shoot-through">Preventing Shoot-through</h3>

<p>The easiest way to implement a shoot-through prevention circuit is to use an integrated circuit (IC) that has shoot-through protection built-in.  The Si9986 IC from Vishay is an H-bridge motor driver circuit with built-in shoot-through protection as well as logic translation circuitry (Q5A and Q5B in the diagram above).  It is a great solution for controlling a small DC motor using a PWM signal from a microcontroller.  When using the Si9986, as with using any motor driver, a snubber circuit is required to reduce electromagnetic noise in the system.</p>

<h3 id="a-snubber-circuit-to-decrease-noise">A Snubber Circuit to Decrease Noise</h3>

<p>A snubber circuit is used to suppress the voltage transients caused by PWM switching (as well as by the inherent switching in brushed motors).  A DC motor is an inductive load; the voltage across which is proportional to the change in current, given by:</p>

<p><img class="post_equation" src="/images/inductor-voltage-formula.svg" /></p>

<p>When the PWM signal switches the motor from on to off, there is a rapid change 
in current (ie di/dt is large) which causes a voltage spike.  Without a snubber 
circuit, the energy from the voltage spike can result in arcing, damage to the 
body diode in the H-bridge transistors, or cause electromagnetic interference 
in nearby circuitry.  The snubber circuit safely dissipates the energy in 
passive elements.  A simple, effective snubber circuit consists of a resistor 
and capacitor in series across the terminals of the motor as shown below.</p>

<p><img class="post_image" src="/images/motorsnubber.png" /></p>

<h3 id="pid-control">PID Control</h3>

<p>With an H-bridge, a pair of PWM signals, and a snubber circuit, the motor is ready for bi-directional control.  The simplest form of control is open loo This means the controller simply applies a voltage (a PWM signal in this case) but has no way to measure the effect of the applied voltage.  The controller simply assumes higher voltage makes the motor go faster.  Closed loop control uses feedback from the motor, such as the motor current or speed, to adjust the PWM signal.</p>

<p>A PID loop–verbosely known as proportional, integral, differential loop–is a popular algorithm in many closed loop systems.</p>

<h3 id="pid-loop">PID loop</h3>

<p><img class="post_image" src="/images/pid_en.png" /></p>

<p>Image from Wikipedia</p>

<p>The diagram above represents a PID controlled process.  In this case, the “process” or “plant” is the motor.  The feedback mechanism–y(t) called the process variable–can be either the motor current or speed.  The set point, u(t), is the desired current or speed.  The PID loop takes the difference (or error), e(t), between the set point and the process variable, applies namesake adjustments–proportional, integral, as well as differential–and then sums the result to get the new value of the manipulated variable (the PWM duty cycle).</p>

<p>The following code is a PID loop implementation using floating point variables.  The structure (pid_f_t) is first initialized using pid_init_f() with the minimum and maximum values for the manipulated variable accepted as parameters.  The minimum is useful if the motor requires some minimum PWM duty cycle to make it turn while the maximum ensures the PID algorithm does not try to exceed 100% duty cycle.  The pid_update_f() function uses the current set point and the process variable as well as the constants stored in the pid_f_t structure to compute the manipulated variable.  The application loop includes a function to measure the motor current or speed, call pid_update_f(), and set the PWM value according to the manipulated variable.</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
  <span class="kt">float</span> <span class="n">max</span> <span class="cm">/*! Max manipulated value */</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">min</span> <span class="cm">/*! Miniumum manipulated value */</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">e</span> <span class="cm">/*! Error value */</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">i</span> <span class="cm">/*! Integrator value */</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">kp</span> <span class="cm">/*! Proportional constant */</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">ki</span> <span class="cm">/*! Integrator constant */</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">kd</span> <span class="cm">/*! Differential constant */</span><span class="p">;</span>
<span class="p">}</span> <span class="kt">pid_f_t</span><span class="p">;</span>
 
<span class="cm">/*! \details This function initializes the data in a PID structure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pid_init_f</span><span class="p">(</span><span class="kt">pid_f_t</span> <span class="o">*</span> <span class="n">ptr</span> <span class="cm">/*! A pointer to the PID data structure */</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="cm">/*! The manipulated variable&#39;s minimum value */</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">max</span> <span class="cm">/*! The manipulated variable&#39;s maximum value */</span><span class="p">){</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">pid_f_t</span><span class="p">));</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="cm">/*! \details This function updates the value of the manipulated variable (MV)</span>
<span class="cm"> * based on the current state of the PID loop.</span>
<span class="cm"> */</span>
<span class="kt">float</span> <span class="nf">pid_update_f</span><span class="p">(</span><span class="kt">float</span> <span class="n">sp</span> <span class="cm">/*! The set point */</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">pv</span> <span class="cm">/*! The process variable */</span><span class="p">,</span>
    <span class="kt">pid_f_t</span> <span class="o">*</span> <span class="n">ptr</span> <span class="cm">/*! A pointer to the PID constants */</span><span class="p">){</span>
  <span class="kt">float</span> <span class="n">temp</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">e</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">p</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">manp</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">tmpi</span><span class="p">;</span>
  <span class="n">e</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">e</span> <span class="o">=</span> <span class="n">sp</span> <span class="o">-</span> <span class="n">pv</span><span class="p">;</span>
  <span class="n">tmpi</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">+</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">;</span>
  <span class="c1">//bound the integral</span>
  <span class="n">manp</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">kp</span> <span class="o">*</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">e</span> <span class="o">+</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">ki</span> <span class="o">*</span> <span class="n">tmpi</span> <span class="o">+</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">kd</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">manp</span> <span class="o">&lt;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="p">(</span><span class="n">manp</span> <span class="o">&gt;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">)</span> <span class="p">){</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="n">tmpi</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">manp</span> <span class="o">&gt;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">max</span> <span class="p">){</span>
    <span class="n">manp</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">manp</span> <span class="o">&lt;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">min</span> <span class="p">){</span>
    <span class="n">manp</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">manp</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>It is important to properly apply the manipulated variable to the process.  In the H-bridge shown above, Q5 inverts the PWM signal which means the software needs to invert the PWM value before applying it.  Also while switching Q2 and Q4, the states of Q1 and Q3 determine the motor direction; this affects how the sign of the manipulated variable is interpreted.  These nuances in the circuit can make debugging a PID loop tricky but can be overcome with sound analysis as well as trial and error.</p>

<h3 id="example">Example</h3>

<p>Here is an example circuit and code using the Laertes Lite Microcomputer running CoActionOS, a 12V DC motor connected to a rotary encoder, and the Si9986 H-Bridge driver chiThe image below shows the breadboard setup.</p>

<h4 id="hardware-setup">Hardware Setup</h4>

<p><img class="post_image" src="/images/motordemo.jpg" /></p>

<p>The parts include:</p>

<ol>
  <li><a href="http://www.coactionos.com/getting-started/33-getting-started-123/89-buy-the-hardware-details.html">CoAction Hero Microcomputer</a></li>
  <li>SMT to DIP Adapter and Si89986 H-Bridge PWM Driver</li>
  <li>Generic 12V DC Brushed Motor</li>
  <li>Rotary Motor Encoder (200 counts per revolution from Sparkfun Electronics)</li>
  <li>10K Potentiometer (used for user input)</li>
</ol>

<p>The following drawing shows the specific connections. The user input (to set the speed) consists of a potentiometer wiper connected to P0.2 (ADC Channel 7). The rotary encoder is connected to P1.26 which also serves as a clock input for timer zero. Finally, 2.3 and 2.4 are PWM outputs connected to the input of the Si9986 H-bridge driver. For more details, please see the “CoAction Hero Microcomputer”:http://www.coactionos.com/getting-started/33-getting-started-123/89-buy-the-hardware-details.html page where the schematic and datasheet are available.</p>

<p><img class="post_image" src="/images/motordemo-drawing.png" /></p>

<h3 id="source-code">Source Code</h3>

<p>The source code uses a PID loop to control the motor speed. First, it reads the ADC to calculate a speed setting from 1500RPM to 10,000RPM which is set by the user using the potentiometer. After the ADC is sampled, it is filtered using an exponential moving average, low-pass filter. This prevents noise on the ADC from causing changes to the speed setting. The code then calculates the motor speed in revolutions per minute. It measures the rising edges of the rotary encoder (200 counts per revolution) using the timer clock input. It then uses the POSIX function (provided by CoActionOS) clock_gettime() to calculate the change in time since the last measurement. The current speed is then the change in number of revolutions divided by the change in time. The current speed and the set point speed are then passed to the PID calculation which returns the duty cycle which is applied to the PWM output.</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;applib/pwm.h&gt;</span>
<span class="cp">#include &lt;applib/tmr.h&gt;</span>
<span class="cp">#include &lt;applib/adc.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>
<span class="cp">#include &lt;dsp.h&gt;</span>
<span class="cp">#include &lt;pid.h&gt;</span>
 
<span class="cp">#define TMR_PORT 0 </span><span class="c1">//Timer port used to capture encoder data</span>
<span class="cp">#define ADC_PORT 0 </span><span class="c1">//ADC port for getting user input</span>
<span class="cp">#define ADC_INPUT_CHAN (7) </span><span class="c1">//ADC channel for user input</span>
<span class="cp">#define PWM_PORT 1 </span><span class="c1">//PWM port for Si9986</span>
<span class="cp">#define PWM_CHAN_HIGH (PWM_CHANNEL5)</span>
<span class="cp">#define PWM_CHAN_LOW (PWM_CHANNEL4)</span>
<span class="cp">#define PWM_FREQ (1000000)  </span><span class="c1">//PWM clock frequency</span>
<span class="cp">#define PWM_TOP 1000 </span><span class="c1">//Top value for PWM clock</span>
<span class="cp">#define PWM_PERIOD (PWM_TOP*1000/PWM_FREQ) </span><span class="c1">//Period in ms</span>
 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">//initilize timer, PWM and ADC</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_tmr</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_pwm</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_adc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 
<span class="c1">//Set the output duty cycle</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_duty</span><span class="p">(</span><span class="kt">int</span> <span class="n">duty</span><span class="p">);</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
  <span class="kt">pwm_reqattr_t</span> <span class="n">req</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 
  <span class="c1">//These are for sampling the ADC (user input)</span>
  <span class="kt">adc_sample_t</span> <span class="n">samp</span><span class="p">;</span>
  <span class="kt">int32_t</span> <span class="n">samp_avg</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">alpha</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">set_speed</span><span class="p">;</span>
 
  <span class="c1">//This is for measuring the motor speed</span>
  <span class="kt">uint32_t</span> <span class="n">delta_ms</span><span class="p">;</span> <span class="c1">//elapsed time in milliseconds</span>
  <span class="kt">uint32_t</span> <span class="n">last_ms</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">now_ms</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">ref_ms</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">current_pos</span><span class="p">;</span> <span class="c1">//current position</span>
  <span class="kt">uint32_t</span> <span class="n">last_pos</span><span class="p">;</span> <span class="c1">//position from last measurement</span>
  <span class="kt">uint32_t</span> <span class="n">delta_pos</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">speed</span><span class="p">;</span>
 
  <span class="c1">//PID variables</span>
  <span class="kt">pid_i32_t</span> <span class="n">pid</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">duty</span><span class="p">;</span>
 
  <span class="k">if</span><span class="p">(</span> <span class="n">init</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
                <span class="c1">//exit unsuccessfully if any hardware failed to initialize</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
 
  <span class="c1">//Initialize the ADC averaging (EMA filter)</span>
  <span class="n">alpha</span> <span class="o">=</span> <span class="n">DSP_EMA_I32_ALPHA</span><span class="p">(</span><span class="mf">0.1</span><span class="p">);</span>
  <span class="n">adc_read</span><span class="p">(</span><span class="n">ADC_PORT</span><span class="p">,</span> <span class="n">ADC_INPUT_CHAN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">samp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">adc_sample_t</span><span class="p">));</span>
  <span class="n">samp_avg</span> <span class="o">=</span> <span class="n">samp</span><span class="p">;</span>
 
  <span class="c1">//Since there is no initial measurement, the first speed will be bogus</span>
  <span class="n">last_ms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 
  <span class="c1">//initialize the PID</span>
  <span class="n">pid_init_i32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">900</span><span class="p">);</span> <span class="c1">//Bound the duty between 20% and 90%</span>
  <span class="n">pid_setconstants_i32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">,</span>
                        <span class="c1">//These constants take some tweaking to get everything to work smoothly</span>
      <span class="n">PID_I32_CONSTANT</span><span class="p">(</span><span class="mf">0.05</span><span class="p">),</span> <span class="c1">//P constant</span>
      <span class="n">PID_I32_CONSTANT</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span> <span class="c1">//I constant</span>
      <span class="n">PID_I32_CONSTANT</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>  <span class="c1">//D constant</span>
      <span class="p">);</span>
 
  <span class="n">usleep</span><span class="p">(</span><span class="mi">50</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span>
  <span class="n">set_duty</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 
  <span class="c1">//Get the initial time so that the program start time is close to zero in the output data</span>
  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_REALTIME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
  <span class="n">ref_ms</span> <span class="o">=</span> <span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="mi">500000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">);</span> <span class="c1">//convert to milliseconds</span>
 
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
    <span class="c1">//Read and averge the ADC to get the set point</span>
    <span class="n">adc_read</span><span class="p">(</span><span class="n">ADC_PORT</span><span class="p">,</span> <span class="n">ADC_INPUT_CHAN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">samp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">adc_sample_t</span><span class="p">));</span>
    <span class="n">samp_avg</span> <span class="o">=</span> <span class="n">dsp_ema_i32</span><span class="p">(</span><span class="n">samp</span><span class="p">,</span> <span class="n">samp_avg</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
    <span class="n">set_speed</span> <span class="o">=</span> <span class="n">samp_avg</span> <span class="o">*</span> <span class="mi">8500</span> <span class="o">/</span> <span class="n">ADC_MAX</span> <span class="o">+</span> <span class="mi">1500</span><span class="p">;</span>
 
    <span class="c1">//Now measure the position and calculate the speed (pos/time)</span>
    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_REALTIME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
    <span class="n">now_ms</span> <span class="o">=</span> <span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="mi">500000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">);</span> <span class="c1">//convert to milliseconds</span>
    <span class="n">delta_ms</span> <span class="o">=</span> <span class="n">now_ms</span> <span class="o">-</span> <span class="n">last_ms</span><span class="p">;</span>
    <span class="n">last_ms</span> <span class="o">=</span> <span class="n">now_ms</span><span class="p">;</span>
 
 
    <span class="n">current_pos</span> <span class="o">=</span> <span class="n">tmr_get</span><span class="p">(</span><span class="n">TMR_PORT</span><span class="p">);</span>
    <span class="n">delta_pos</span> <span class="o">=</span> <span class="n">current_pos</span> <span class="o">-</span> <span class="n">last_pos</span><span class="p">;</span>
    <span class="c1">//calculate in RPM (1000*60 ms in a min and 200 counts per revolution)</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta_pos</span><span class="o">*</span><span class="p">(</span><span class="mi">1000</span><span class="o">*</span><span class="mi">60</span><span class="o">/</span><span class="mi">200</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">delta_ms</span><span class="p">);</span>
    <span class="n">last_pos</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">;</span>
 
    <span class="c1">//Calculate the new duty cycle</span>
    <span class="n">duty</span> <span class="o">=</span> <span class="n">pid_update_i32</span><span class="p">(</span><span class="n">set_speed</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
    <span class="n">set_duty</span><span class="p">(</span><span class="n">duty</span><span class="p">);</span>
 
    <span class="c1">//Display the data and wait for the next update</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">i</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">){</span> <span class="c1">//first sample is garbage because the delta values are invalid</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d %d %d;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">now_ms</span> <span class="o">-</span> <span class="n">ref_ms</span><span class="p">,</span> <span class="n">set_speed</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">duty</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">usleep</span><span class="p">(</span><span class="mi">25</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span> <span class="c1">//update every 25 ms</span>
  <span class="p">}</span>
 
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">init</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">init_tmr</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">init_adc</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">init_pwm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">init_tmr</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="kt">tmr_attr_t</span> <span class="n">attr</span><span class="p">;</span>
 
  <span class="c1">//Open the timer port</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">tmr_open</span><span class="p">(</span><span class="n">TMR_PORT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;failed to open tmr&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="c1">//We are using Capture 0 on timer 0 (CAP0. -- count rising edges</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">clksrc</span> <span class="o">=</span> <span class="n">TMR_CLKSRC_IC0</span> <span class="o">|</span> <span class="n">TMR_CLKSRC_EDGERISING</span><span class="p">;</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//this is not used with input capture counting</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">enabled_ic_chans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//not used</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">enabled_oc_chans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//not used</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">pin_assign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//From the datasheet, this pin is using TMR1(0) where 0 is the pin assignment</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">tmr_setattr</span><span class="p">(</span><span class="n">TMR_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;failed to setattr tmr&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="c1">//Turn the timer on (start counting edges)</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">tmr_on</span><span class="p">(</span><span class="n">TMR_PORT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;failed to turn tmr on&quot;</span><span class="p">);</span>
  <span class="p">}</span>
 
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">init_pwm</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="kt">pwm_attr_t</span> <span class="n">attr</span><span class="p">;</span>
  <span class="kt">pwm_reqattr_t</span> <span class="n">req</span><span class="p">;</span>
 
  <span class="c1">//Open the PWM port</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">pwm_open</span><span class="p">(</span><span class="n">PWM_PORT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;failed to open pwm&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="c1">//Set the PWM attributes</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">enabled_channels</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">PWM_CHAN_HIGH</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">PWM_CHAN_LOW</span><span class="p">);</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">PWM_FREQ</span><span class="p">;</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">top</span> <span class="o">=</span> <span class="n">PWM_TOP</span><span class="p">;</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">pin_assign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//Using PWM1(1) from the datasheet the (1) means pin assignment 1</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">pwm_setattr</span><span class="p">(</span><span class="n">PWM_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;failed to setattr pwm&quot;</span><span class="p">);</span>
  <span class="p">}</span>
 
  <span class="c1">//Allow the PWM clock time to initialize</span>
  <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span>
 
  <span class="c1">//Set both PWM outputs to Zero</span>
  <span class="n">req</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">PWM_CHAN_HIGH</span><span class="p">;</span>
  <span class="n">req</span><span class="p">.</span><span class="n">duty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">pwm_set</span><span class="p">(</span><span class="n">PWM_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;failed to set high duty&quot;</span><span class="p">);</span>
  <span class="p">}</span>
 
  <span class="n">req</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">PWM_CHAN_LOW</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">pwm_set</span><span class="p">(</span><span class="n">PWM_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;failed to set low duty&quot;</span><span class="p">);</span>
  <span class="p">}</span>
 
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">init_adc</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="kt">adc_attr_t</span> <span class="n">attr</span><span class="p">;</span>
 
  <span class="c1">//Open the ADC port</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">adc_open</span><span class="p">(</span><span class="n">ADC_PORT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;failed to open adc&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="c1">//Set the ADC attributes</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">enabled_channels</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADC_INPUT_CHAN</span><span class="p">);</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">ADC_MAX_FREQ</span><span class="p">;</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">pin_assign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">adc_setattr</span><span class="p">(</span><span class="n">ADC_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;failed to setattr for adc&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="nf">set_duty</span><span class="p">(</span><span class="kt">int</span> <span class="n">duty</span><span class="p">){</span>
  <span class="kt">pwm_reqattr_t</span> <span class="n">req</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">duty</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">){</span>
    <span class="c1">//This turns on the brake -- both outputs low</span>
    <span class="n">req</span><span class="p">.</span><span class="n">duty</span> <span class="o">=</span> <span class="n">duty</span><span class="p">;</span>
    <span class="n">req</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">PWM_CHAN_HIGH</span><span class="p">;</span>
    <span class="n">pwm_set</span><span class="p">(</span><span class="n">PWM_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
    <span class="n">req</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">PWM_CHAN_LOW</span><span class="p">;</span>
    <span class="n">pwm_set</span><span class="p">(</span><span class="n">PWM_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">//This runs in run mode -- one output is switching the other is high</span>
    <span class="n">req</span><span class="p">.</span><span class="n">duty</span> <span class="o">=</span> <span class="n">PWM_TOP</span> <span class="o">-</span> <span class="n">duty</span><span class="p">;</span>
    <span class="n">req</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">PWM_CHAN_HIGH</span><span class="p">;</span>
    <span class="n">pwm_set</span><span class="p">(</span><span class="n">PWM_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
    <span class="n">req</span><span class="p">.</span><span class="n">duty</span> <span class="o">=</span> <span class="n">PWM_TOP</span><span class="p">;</span>
    <span class="n">req</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">PWM_CHAN_LOW</span><span class="p">;</span>
    <span class="n">pwm_set</span><span class="p">(</span><span class="n">PWM_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<h3 id="results">Results</h3>

<p>To see how the well the code works, the output is plotted against time using the following MATLAB (or octave) script.</p>

<pre>
output = load("log.txt");
plot(output);
xmin = min( output(:,1) );
xmax = max( output(:,1) );
ymax = 10000;
plot(output(:,1), output(:,2), output(:,1), output(:,3), output(:,1), output(:,4) );
xlabel("Time (ms)");
ylabel("Speed");
axis([xmin xmax 0 ymax]);
legend("Set Point", "Speed", "Duty*1000");
print("output.png", "-dpng");
</pre>

<p>The following shows the motor speed, duty cycle (per one thousand), and the actual speed.</p>

<p><img class="post_image" src="/images/motordemoplot.png" /></p>

<p>To get the above performance, the PID constants required tweaking. The approach was to set the I and D values to zero and monitor the performance by changing the P value. Once a stable P value was found, the I value was adjusted to find a good trade-off between accuracy and stability. Finally, the D constant–the least significant in this application–was set.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Precision, bi-directional motor control is achievable in embedded designs using an H-bridge driver, circuitry to sense feedback from the motor, and a PID algorithm.  It is important to have a well designed H-bridge that prevents shoot-through and suppresses electomagnetic interference with a snubber circuit.  The sensing feedback can come in the form of speed (using encoders) or current; though, the best results will be achieved using an encoder.  Finally, the PID algorithm can be tuned to ensure the control algorithm meets the application’s requirements.</p>


				</div>
			</div>

			
			<ul class="nav nav-pills">
				
				


  
     
    	<li><a href="/tags.html#embedded-ref">embedded <span class="badge">36</span></a></li>
     
    	<li><a href="/tags.html#control-ref">control <span class="badge">7</span></a></li>
     
    	<li><a href="/tags.html#pwm-ref">pwm <span class="badge">2</span></a></li>
     
    	<li><a href="/tags.html#pid-ref">pid <span class="badge">1</span></a></li>
     
    	<li><a href="/tags.html#motor-ref">motor <span class="badge">1</span></a></li>
     
    	<li><a href="/tags.html#programming-ref">programming <span class="badge">9</span></a></li>
     
    	<li><a href="/tags.html#circuit-ref">circuit <span class="badge">7</span></a></li>
     
    	<li><a href="/tags.html#popular-ref">popular <span class="badge">11</span></a></li>
    
  



			</ul>
			
			<div class="pagination">
				<center>
					 
						<a href="/embedded%20design%20tips/2013/10/14/Tips-How-Microcontrollers-Work" type="button" class="btn btn-primary"
							data-toggle="tooltip" data-placement="left" title="" data-original-title="Previous Post"
							>
							<i class="fa fa-arrow-left"></i>
						</a> 
					 
					<a href="/archive.html" type="button" class="btn btn-primary"
						data-toggle="tooltip" data-placement="top" title="" data-original-title="Archives"
						>
						<i class="fa fa-archive"></i>
					</a> 
					<a href="/categories.html" type="button" class="btn btn-primary"
						data-toggle="tooltip" data-placement="top" title="" data-original-title="Categories"
					>
						<i class="fa fa-folder-open"></i>
					</a> 
					 
						<a href="/embedded%20design%20tips/2013/10/18/Tips-RAM-Flash-Usage-in-Embedded-C-Programs" type="button" class="btn btn-primary"
							data-toggle="tooltip" data-placement="right" title="" data-original-title="Next Post"
							>
							<i class="fa fa-arrow-right"></i>
						</a>
					
				</center>
			</div>
				
		</div>
		<div class="col-md-3">
		

			<h3>Embedded Design Tips</h3>
			<ul class="nav nav-pills nav-stacked">
				
				
				


  
    
      
      	
      	<li class='tagged embedded gcc compiler macosx'><a href="/embedded%20design%20tips/2014/10/05/Tips-Building-and-Installing-a-Cortex-M4-Compiler-on-Mac-OS-X">Building and Installing a Cortex-M4 Compiler on Mac OS X</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded microcontroller arm cortex-m3 coaction'><a href="/embedded%20design%20tips/2014/05/03/Applications-without-MMU">Applications without an MMU</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged doxygen javascript bootstrap'><a href="/embedded%20design%20tips/2014/01/07/Tips-Integrating-Doxygen-and-Bootstrap">Integrating Doxygen and Bootstrap</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded circuit'><a href="/embedded%20design%20tips/2013/10/27/Tips-Using-Op-Amps-in-Embedded-Design">Using Op Amps in Embedded Design</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded control gpio'><a href="/embedded%20design%20tips/2013/10/26/Tips-Controlling-a-Solenoid">Controlling a Solenoid</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded gpio circuit microcontroller popular'><a href="/embedded%20design%20tips/2013/10/25/Tips-Using-Pull-Up-and-Pull-Down-Resistors">Using Pull-Up and Pull-Down Resistors</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded circuit led control'><a href="/embedded%20design%20tips/2013/10/24/Tips-Using-LEDs-in-Embedded-Designs">Using LEDs in Embedded Designs</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded c doxygen programming'><a href="/embedded%20design%20tips/2013/10/23/Tips-Using-Doxygen-with-C">Using Doxygen with C</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded usb programming microcontroller serial'><a href="/embedded%20design%20tips/2013/10/22/Tips-USB-Virtual-Serial-Port-Firmware">USB Virtual Serial Port Firmware</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded microcontroller gpio programming'><a href="/embedded%20design%20tips/2013/10/21/Tips-Understanding-Microcontroller-Pin-Input-Output-Modes">Understanding Microcontroller Pin Input/Output Modes</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded circuit sensor filter adc programming'><a href="/embedded%20design%20tips/2013/10/19/Tips-Sensing-the-Source-Current-in-an-Embedded-Application">Sensing the Source Current in an Embedded Application</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded c programming popular'><a href="/embedded%20design%20tips/2013/10/18/Tips-RAM-Flash-Usage-in-Embedded-C-Programs">RAM/Flash Usage in Embedded C Programs</a></li>
      	
      
    
  
    
      
      	
      	<li class='active tagged embedded control pwm pid motor programming circuit popular'><a href="/embedded%20design%20tips/2013/10/15/Tips-Motor-Control-using-PWM-and-PID" class="active">Motor Control using PWM and PID</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded microcontroller circuit'><a href="/embedded%20design%20tips/2013/10/14/Tips-How-Microcontrollers-Work">How Microcontrollers Work</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded cortex-m3 fft filter popular'><a href="/embedded%20design%20tips/2013/10/13/Tips-FFT-on-the-ARM-Cortex-M3">FFT on the ARM Cortex M3</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded cortex-m3'><a href="/embedded%20design%20tips/2013/10/12/Tips-Effective-Use-of-ARM-Cortex-M3-SVCall">Effective Use of ARM Cortex-M3 SVCall</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded macosx qt'><a href="/embedded%20design%20tips/2013/10/11/Tips-Deploying-Qt-Applications-on-Mac-OSX">Deploying Qt Applications on Mac OSX</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded circuit power popular'><a href="/embedded%20design%20tips/2013/10/10/Tips-Decoupling-Capacitors">Decoupling Capacitors (and Other Power Rules of Thumb)</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded cortex-m3 threads popular'><a href="/embedded%20design%20tips/2013/10/09/Tips-Context-Switching-on-the-Cortex-M3">Context Switching on the Cortex-M3</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded compiler gcc'><a href="/embedded%20design%20tips/2013/10/08/Tips-Building-and-Installing-Autotools">Building and Installing Autotools</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded gcc compiler linux'><a href="/embedded%20design%20tips/2013/10/07/Tips-Building-and-Installing-a-Cortex-M3-Compiler-on-Ubuntu">Building and Installing a Cortex-M3 Compiler on Ubuntu</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded gcc compiler macosx'><a href="/embedded%20design%20tips/2013/10/06/Tips-Building-and-Installing-a-Cortex-M3-Compiler-on-Mac-OS-X">Building and Installing a Cortex-M3 Compiler on Mac OS X</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded gcc compiler windows'><a href="/embedded%20design%20tips/2013/10/05/Tips-Building-and-Installing-a-Cortex-M3-Compiler-in-Windows">Building and Installing a Cortex-M3 Compiler in Windows</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded filter iir programming popular'><a href="/embedded%20design%20tips/2013/10/04/Tips-An-Easy-to-Use-Digital-Filter">An Easy-to-Use Digital Filter</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded adc lookup-table c programming'><a href="/embedded%20design%20tips/2013/10/03/Tips-ADC-Thermistor-Circuit-and-Lookup-Table">ADC Thermistor Circuit and Lookup Table</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded fifo uart serial microcontroller programming popular'><a href="/embedded%20design%20tips/2013/10/02/Tips-A-FIFO-Buffer-Implementation">A FIFO Buffer Implementation</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded microcontroller popular'><a href="/embedded%20design%20tips/2013/10/01/Tips-8-vs-16-vs-32-Bit-Microcontrollers">8 vs 16 vs 32 Bit Microcontrollers--A Case Study</a></li>
      	
      
    
  



			</ul>
			
			
				<h3>Embedded C Tutorial</h3>
				<ul class="nav nav-pills nav-stacked">
					  
					


  
    
      
      	
      	<li class='tagged embedded tutorial'><a href="/embedded%20c%20tutorial/2013/12/11/Embedded-C-Tutorial-Order-of-Operations">Order of Operations Reference</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded tutorial'><a href="/embedded%20c%20tutorial/2013/12/10/Embedded-C-Tutorial-Keyword-Reference">Keywords Reference</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded tutorial'><a href="/embedded%20c%20tutorial/2013/12/09/Embedded-C-Tutorial-Compound-Data-Types">Compound Data Types</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded tutorial'><a href="/embedded%20c%20tutorial/2013/12/08/Embedded-C-Tutorial-Preprocessor">Preprocessor Directives</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded tutorial'><a href="/embedded%20c%20tutorial/2013/12/07/Embedded-C-Tutorial-Pointers-and-Arrays">Pointers and Arrays</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded tutorial'><a href="/embedded%20c%20tutorial/2013/12/05/Embedded-C-Tutorial-Flow-Control">Flow Control</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded tutorial'><a href="/embedded%20c%20tutorial/2013/12/04/Embedded-C-Tutorial-Operators">Operators</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded tutorial'><a href="/embedded%20c%20tutorial/2013/12/03/Embedded-C-Tutorial-Raw-Types">Raw Types</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded tutorial'><a href="/embedded%20c%20tutorial/2013/12/02/Embedded-C-Tutorial-Functions">Functions</a></li>
      	
      
    
  
    
      
      	
      	<li class='tagged embedded tutorial popular'><a href="/embedded%20c%20tutorial/2013/12/01/Embedded-C-Tutorial-Hello-World">Hello World</a></li>
      	
      
    
  



				</ul>
			
			
			
			  
		</div>
	</div>

</div>



	</div>

	<footer style="background: #344555; color: #fff;">
		<div class="container">
			<div class="row" style="margin-top: 20px; margin-bottom: 20px; ">
				<div class="col-md-12">
					<p>&copy; 2016 Stratify Labs, Inc</p>
				</div>
			</div>
		</div>
	</footer>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-21543723-3', 'coactionos.com');
  ga('send', 'pageview');

</script>
 </body>
</html>

