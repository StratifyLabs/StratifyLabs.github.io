---
layout: page
title: Stratify OS Docs
---
{% include JB/setup %}
<script type="text/javascript" src="doxy-boot.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">MCU_PACK Struct Reference<div class="ingroups"><a class="el" href="group___s_t_f_y.html">Stratify OS</a><a class="el" href="group___s_t_f_y.html">Stratify OS</a> &raquo; <a class="el" href="group___u_s_b___d_e_v.html">USB Device</a> &raquo;  &#124; <a class="el" href="group___u_s_b___d_e_v___a_d_c.html">Audio Device Class</a><a class="el" href="group___s_t_f_y.html">Stratify OS</a> &raquo; <a class="el" href="group___u_s_b___d_e_v.html">USB Device</a> &raquo;  &#124; <a class="el" href="group___u_s_b___d_e_v___h_i_d.html">Human Interface Device</a><a class="el" href="group___s_t_f_y.html">Stratify OS</a> &raquo; <a class="el" href="group___u_s_b___d_e_v.html">USB Device</a> &raquo;  &#124; <a class="el" href="group___u_s_b_d_e_f_s.html">USB Definitions</a> &#124; <a class="el" href="group___d_e_v_i_c_e.html">Device Configuration</a> &#124; <a class="el" href="group___link.html">Layer</a> &#124; <a class="el" href="group___a_d_c.html">Analog to Digital Converter (ADC)</a> &#124; <a class="el" href="group___b_o_o_t_l_o_a_d_e_r___d_e_v.html">Bootloader Access</a> &#124; <a class="el" href="group___c_o_r_e.html">Core Microcontroller Access</a> &#124; <a class="el" href="group___d_a_c.html">Digital to Analog Converter (DAC)</a> &#124; <a class="el" href="group___s_y_s___d_e_v_f_i_f_o.html">Device FIFO</a> &#124; <a class="el" href="group___d_i_s_k.html">Disk</a> &#124; <a class="el" href="group___e_i_n_t.html">External Interrupts (EINT)</a> &#124; <a class="el" href="group___e_m_c.html">External Memory Controller (EMC)</a> &#124; <a class="el" href="group___e_t_h___d_e_v.html">Ethernet Device Access</a> &#124; <a class="el" href="group___s_y_s___f_i_f_o.html">FIFO Buffer</a> &#124; <a class="el" href="group___f_l_a_s_h.html">Flash Memory</a> &#124; <a class="el" href="group___g_p_i_o.html">General Purpose Input/Output (GPIO)</a> &#124; <a class="el" href="group___h_i_o.html">Human Input/Output Device</a> &#124; <a class="el" href="group___i2_c.html">Inter-Integrated Circuit (I2C) Master</a> &#124; <a class="el" href="group___i2_s.html">Inter-Integrated Circuit (I2S) Master</a> &#124; <a class="el" href="group___m_c_i.html">Multimedia Card Interface</a> &#124; <a class="el" href="group___m_e_m.html">Memory (RAM/Flash)</a> &#124; <a class="el" href="group___m_l_c_d.html">Mono LCD</a> &#124; <a class="el" href="group___p_i_o.html">Pin Input/Output (PIO)</a> &#124; <a class="el" href="group___p_w_m.html">Pulse Width Modulation (PWM)</a> &#124; <a class="el" href="group___q_e_i.html">Quadrature Encoder Interface (QEI)</a> &#124; <a class="el" href="group___r_t_c.html">Real Time Clock (RTC)</a> &#124; <a class="el" href="group___s_p_i.html">Serial Peripheral Interface (SPI) Master</a> &#124; <a class="el" href="group___s_y_s___d_e_v.html">System Devices</a> &#124; <a class="el" href="group___t_m_r.html">Timer (TMR)</a> &#124; <a class="el" href="group___u_a_r_t.html">Universal Asynchronous Receiver/Transmitter (UART)</a> &#124; <a class="el" href="group___u_s_b.html">Universal Serial Bus (USB)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Data structure for on-chip MCU peripherals.  
 <a href="struct_m_c_u___p_a_c_k.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="device__config_8h_source.html">device_config.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for MCU_PACK:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="struct_m_c_u___p_a_c_k__coll__graph.svg" width="214" height="382"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>USB Attribute Data Structure.</p>
<p>UART Attribute Data Structure.</p>
<p>Timer Attribute Data Structure.</p>
<p>A Timer Channel (OC or IC) Request Data.</p>
<p>Data structure to unlock the security word features.</p>
<p>Structure for checking the status of a named process.</p>
<p>Structure for I_SYS_KILL and I_SYS_PTHREADKILL.</p>
<p>Task Attributes.</p>
<p>SPI Attribute Data Structure.</p>
<p>RTC IO Attributes.</p>
<p>RTC Alarm including Time and Alarm Type.</p>
<p>RTC Time Structure (compatible with struct tm from time.h)</p>
<p>QEI IO Attributes.</p>
<p>Structure to set the duty cycle of a channel.</p>
<p>PWM Attribute Data Structure.</p>
<p>IO port and pin.</p>
<p>Monochrome LCD attributes.</p>
<p>Holds the characteristics of a page.</p>
<p>Holds the devices attributes.</p>
<p>PIO Attribute Data Structure.</p>
<p>I2S IO Attributes.</p>
<p>I2C IO Attributes.</p>
<p>Data used to setup I2C transfers.</p>
<p>HIO attributes.</p>
<p>Descriptor entry.</p>
<p>GPIO Attribute Data Structure.</p>
<p>Flash page write data using I_FLASH_WRITEPAGE.</p>
<p>FIFO Configuration.</p>
<p>FIFO Peek data.</p>
<p>FIFO Attributes.</p>
<p>ETH IO Attributes.</p>
<p>External Interrupt Attribute Data Structure.</p>
<p>EEPROM Attribute Data Structure.</p>
<p>Disk attributes.</p>
<p>DAC Attribute Data Structure.</p>
<p>Data structure used for setting interrupt priorities.</p>
<p>Data structure for setting the pin functionality.</p>
<p>Core IO Attributes.</p>
<p>Used with I_CORE_SETCLKOUT.</p>
<p>See details below.</p>
<p>Bootloader attributes.</p>
<p>ADC IO Attributes.</p>
<p>HWPL Driver Function Pointers.</p>
<p>Data structure used for reads and writes of devices.</p>
<p>Data structure for device configuration.</p>
<p>Data structure for an analog input device (up to 16 channels)</p>
<p>Data structure for a UART device (RX and TX lines)</p>
<p>Data structure for an I2C device (SCL and SDA lines)</p>
<p>Data structure for a SPI device with a CS pin.</p>
<p>Structure defining a GPIO port/pin combination.</p>
<p>This data structure is used for all on-chip MCU peripherals.</p>
<p>This structure defines a GPIO port/pin combination used in configuring devices.</p>
<p>This data structure defines the data used to implement a device driver which utilizes the SPI port and a single GPIO pin for the chip select.</p>
<p>This structure defines the data structure for configuring a device driver that uses the I2C bus.</p>
<p>This structure defines the data used to configure a device driver which uses the UART to communicate with the device.</p>
<p>This structure defines the data for an analog input device with up to 16 inputs.</p>
<p>This defines the device configuration.</p>
<p>This is the data structure for data transfers.</p>
<p>This structure defines the contents of a HWPL device file. The HWPL device files are stored in local flash rather than on the external flash so that they can be loaded even if there is no filesystem.</p>
<p>This defines the data structure of the reply received from the device.</p>
<p>This structure defines the attributes structure for configuring the ADC port.</p>
<p>This structure contains the attributes for the bootloader.</p>
<p>This structure is used for writing data to the bootloader flash using <a class="el" href="group___b_o_o_t_l_o_a_d_e_r___d_e_v.html#ga026e3631b0b5db5caebf1a8470aaea58">I_BOOTLOADER_WRITEPAGE</a>.</p>
<p>This structure is used to set the clock out attributes (see <a class="el" href="group___c_o_r_e.html#gab18399788c0a6653e37c6b51ab2fa796">I_CORE_SETCLKOUT</a>).</p>
<p>This structure defines the attributes structure for configuring the Core port.</p>
<p>This structure is used with I_CORE_SETPINFUNC to set the functionality of pins.</p>
<p>This data structure is used with the I_CORE_SETIRQPRIO request to set the interrupt priority for peripherals.</p>
<p>This structure defines how the control structure for configuring the DAC port.</p>
<p>This structure defines the attributes used in a device fifo.</p>
<p>This structure defines how the control structure for opening or reconfiguring the EEPROM port.</p>
<p>This data structure is used for controlling external interrupt IO peripherals.</p>
<p>This structure defines the attributes structure for configuring the ethernet port.</p>
<p>This is the enc28j60 tx status attribute.</p>
<p>This structure defines the attributes of a FIFO. The attributes are read-only using <a class="el" href="group___s_y_s___f_i_f_o.html#ga81cb55b73d1c48300efc4f9170781de9">I_FIFO_GETATTR</a>.</p>
<p>This is used when peeking at data in the FIFO</p>
<p>This structure defines the static FIFO configuration.</p>
<p>This structure is used to write data to the flash using I_FLASH_WRITEPAGE.</p>
<p>This structure defines how the control structure for configuring the GPIO port.</p>
<p>This data structure is used with the I_GPIO_SETPINMODE request.</p>
<p>This data structure describes a single entry in the descriptor.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="struct_m_c_u___p_a_c_k.html">hio_desc_t</a> desc[] = {</div><div class="line">     { .<a class="code" href="group___h_i_o.html#gaff1eaaa3781474e219dad215885e5fd6">type</a> = <a class="code" href="group___h_i_o.html#gga7c6c8941505284f2e03ee28e0c3c80fcacfb87fe9636054a27b0ef6e0b9cde341">HIO_TYPE_BIT</a>, .use = <a class="code" href="group___h_i_o.html#ggaba3f829ed128f9908e3ec1ce5ebdd3cda651d5ab299b41d620a0078416ea18207">HIO_IN_BUTTON</a>, .count = 4 }, <span class="comment">//four buttons (located in LSbs)</span></div><div class="line">     { .type = <a class="code" href="group___h_i_o.html#gga7c6c8941505284f2e03ee28e0c3c80fcace071cbafea00f0edbf397a3d02aae65">HIO_TYPE_UINT8</a>, .use = <a class="code" href="group___h_i_o.html#ggaba3f829ed128f9908e3ec1ce5ebdd3cda7ff15162da4aa3527911ee74f6cd03b0">HIO_IN_DPAD</a>, .count = 1 }, <span class="comment">//directional pad</span></div><div class="line">     { .type = <a class="code" href="group___h_i_o.html#gga7c6c8941505284f2e03ee28e0c3c80fcace071cbafea00f0edbf397a3d02aae65">HIO_TYPE_UINT8</a>, .use = <a class="code" href="group___h_i_o.html#ggaba3f829ed128f9908e3ec1ce5ebdd3cdacb35f73142dc58a32b4da7c51f613ced">HIO_OUT_LED</a>, .count = 1 }, <span class="comment">//LED</span></div><div class="line">     { .type = <a class="code" href="group___h_i_o.html#gga7c6c8941505284f2e03ee28e0c3c80fca6458b388ce8dc1961b9b6eb09efcf7f3">HIO_TYPE_INT16</a>, .use = <a class="code" href="group___h_i_o.html#ggaba3f829ed128f9908e3ec1ce5ebdd3cda2634a649969bfd42534a290c54365105">HIO_IN_JOYSTICK</a>, .count = 2 }, <span class="comment">//2-axis joystick x then y</span></div><div class="line">     { .type = <a class="code" href="group___h_i_o.html#gga7c6c8941505284f2e03ee28e0c3c80fca6458b388ce8dc1961b9b6eb09efcf7f3">HIO_TYPE_INT16</a>, .use = <a class="code" href="group___h_i_o.html#ggaba3f829ed128f9908e3ec1ce5ebdd3cda8589c54a0f4975971911d8a8175fbc94">HIO_EXTREMA</a>, .count = 2 }, <span class="comment">//Min  then Max value for the joystick</span></div><div class="line">     };</div><div class="line"></div><div class="line"></div><div class="line">     <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_m_c_u___p_a_c_k.html">MCU_PACK</a> {</div><div class="line">          uint8_t in_button; <span class="comment">//four bits in LSb&#39;s</span></div><div class="line">          uint8_t in_dpad; <span class="comment">//four bits HIO_DPAD_UP, etc</span></div><div class="line">          uint8_t out_led; <span class="comment">//One bit in LSb</span></div><div class="line">          int16_t in_joystick[2]; <span class="comment">//two analog values</span></div><div class="line">          int16_t joystick_extrema[2]; <span class="comment">//min then max value of joystick</span></div><div class="line">     } my_desc_t;</div></div><!-- fragment --><p>This contains the attributes of the human input/output device</p>
<p>This is the I2C transfer setup structure.</p>
<p>This structure defines how the control structure for configuring the I2C port.</p>
<p>This structure defines how the control structure for configuring the I2S port.</p>
<p>This structure defines how the control structure for configuring the PIO port.</p>
<p>This defines the attributes of the memory.</p>
<p>It is used with <a class="el" href="group___m_e_m.html#ga14bd3264693fbe0bd29cfa33f049e340">I_MEM_GETATTR</a>. The attributes are read-only so I_MEM_SETATTR has no effect.</p>
<p>This structure contains the details for a page of memory.</p>
<p>This contains the attributes of a monochrome LCD.</p>
<p>This data structures holds the details of a single port/pin combination.</p>
<p>This structure is used to do a quick write of the PWM value and is used with <a class="el" href="group___p_w_m.html#gac9d07b82e0695639d6ecbbc061b83314">I_PWM_SET</a>.</p>
<p>This structure defines how the control structure for opening or reconfiguring the QEI port.</p>
<p>This structure holds the time. It should be compatible with struct tm.</p>
<p>This structure is used to read and write the RTC alarm using the rtc_ioctl() function.</p>
<p>This data structure defines the structure used with I_GETATTR and I_SETATTR ioctl requests on the RTC. It is also used when opening the RTC.</p>
<p>This structure defines how the control structure for opening or reconfiguring the SPI port.</p>
<p>This structure defines the system attributes.</p>
<p>This structure contains the task attributes used with I_SYS_GETTASK.</p>
<p>This structure is used with the I_SYS_KILL and I_SYS_PHTHREADKILL requests.</p>
<p>This structure is used for checking the status of a named process. It is used with the I_SYS_GETPROCESS request.</p>
<p>This data structure is used with I_SYS_UNLOCK. A successful request will unlock the security features (see <em>security</em> in <a class="el" href="group___s_y_s___d_e_v.html#gaf25ffa9c4b2342a75eba3248bc75fe7a">sys_attr_t</a>) of the device giving access to certain parts of the device.</p>
<p>This is used to turn the specified LED on and off.</p>
<p>This structure is used when dealing with output compare or input capture channels request using tmr_ioctl().</p>
<p>This structure defines how the control structure for opening or reconfiguring a timer port.</p>
<p>This structure defines how the control structure for opening or reconfiguring the UART port.</p>
<p>This defines the USB IOCTL data structure. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a1c35e01dfc85a2e81e439312a5f764d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c35e01dfc85a2e81e439312a5f764d4"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a1c35e01dfc85a2e81e439312a5f764d4">port</a></td></tr>
<tr class="memdesc:a1c35e01dfc85a2e81e439312a5f764d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port number for the peripheral. <br /></td></tr>
<tr class="separator:a1c35e01dfc85a2e81e439312a5f764d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e333ef8b00ba3564def992c481a6f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4e333ef8b00ba3564def992c481a6f5"></a>
i8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ad4e333ef8b00ba3564def992c481a6f5">port</a></td></tr>
<tr class="memdesc:ad4e333ef8b00ba3564def992c481a6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GPIO port number (-1 means not used) <br /></td></tr>
<tr class="separator:ad4e333ef8b00ba3564def992c481a6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4152984b3f23843d1ac534dcaf63e2c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4152984b3f23843d1ac534dcaf63e2c5"></a>
i8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a4152984b3f23843d1ac534dcaf63e2c5">pin</a></td></tr>
<tr class="memdesc:a4152984b3f23843d1ac534dcaf63e2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GPIO pin number. <br /></td></tr>
<tr class="separator:a4152984b3f23843d1ac534dcaf63e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71caa85ea7fdcdf2c16f5a46cc33a70c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71caa85ea7fdcdf2c16f5a46cc33a70c"></a>
<a class="el" href="group___p_i_o.html#gaf8578727d6d1ca42e649beec21752b0a">pio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a71caa85ea7fdcdf2c16f5a46cc33a70c">cs</a></td></tr>
<tr class="memdesc:a71caa85ea7fdcdf2c16f5a46cc33a70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The chip select gpio port/pin. <br /></td></tr>
<tr class="separator:a71caa85ea7fdcdf2c16f5a46cc33a70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafff78771d82f6e3448de9037a19bf1f"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aafff78771d82f6e3448de9037a19bf1f">width</a></td></tr>
<tr class="memdesc:aafff78771d82f6e3448de9037a19bf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The width of a SPI bus word.  <a href="#aafff78771d82f6e3448de9037a19bf1f">More...</a><br /></td></tr>
<tr class="separator:aafff78771d82f6e3448de9037a19bf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b7eeae0a83d14b39385109b87f3578"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a23b7eeae0a83d14b39385109b87f3578">format</a></td></tr>
<tr class="memdesc:a23b7eeae0a83d14b39385109b87f3578"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format the SPI bus uses.  <a href="#a23b7eeae0a83d14b39385109b87f3578">More...</a><br /></td></tr>
<tr class="separator:a23b7eeae0a83d14b39385109b87f3578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10128eaba82516c54ffe672392ed08ec"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a10128eaba82516c54ffe672392ed08ec">mode</a></td></tr>
<tr class="memdesc:a10128eaba82516c54ffe672392ed08ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPI mode (0, 1, 2, or 3)  <a href="#a10128eaba82516c54ffe672392ed08ec">More...</a><br /></td></tr>
<tr class="separator:a10128eaba82516c54ffe672392ed08ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ff9ea7a7eb39629244621abf83e6c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03ff9ea7a7eb39629244621abf83e6c1"></a>
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a03ff9ea7a7eb39629244621abf83e6c1">slave_addr</a></td></tr>
<tr class="memdesc:a03ff9ea7a7eb39629244621abf83e6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The I2C Slave address. <br /></td></tr>
<tr class="separator:a03ff9ea7a7eb39629244621abf83e6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bdb4087af27d1ac7019cefef920d38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13bdb4087af27d1ac7019cefef920d38"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a13bdb4087af27d1ac7019cefef920d38">stop_bits</a></td></tr>
<tr class="memdesc:a13bdb4087af27d1ac7019cefef920d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of stop bits. <br /></td></tr>
<tr class="separator:a13bdb4087af27d1ac7019cefef920d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab875588b48b643d4933fb0a7e3fd920c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab875588b48b643d4933fb0a7e3fd920c"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ab875588b48b643d4933fb0a7e3fd920c">parity</a></td></tr>
<tr class="memdesc:ab875588b48b643d4933fb0a7e3fd920c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Parity (none, odd, or even) <br /></td></tr>
<tr class="separator:ab875588b48b643d4933fb0a7e3fd920c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c2d7a9ed86e9b46ec7795bbb3a3d6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91c2d7a9ed86e9b46ec7795bbb3a3d6b"></a>
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a91c2d7a9ed86e9b46ec7795bbb3a3d6b">reference</a></td></tr>
<tr class="memdesc:a91c2d7a9ed86e9b46ec7795bbb3a3d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference voltage in millivolts. <br /></td></tr>
<tr class="separator:a91c2d7a9ed86e9b46ec7795bbb3a3d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22e1592de32d13be33edac258085ed5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab22e1592de32d13be33edac258085ed5"></a>
i8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ab22e1592de32d13be33edac258085ed5">channels</a> [<a class="el" href="group___d_e_v_i_c_e.html#gac32db06aaae796b77832c68a4f11051b">DEVICE_MAX_ADC_CHANNELS</a>]</td></tr>
<tr class="memdesc:ab22e1592de32d13be33edac258085ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The channels to use (-1) if not used. <br /></td></tr>
<tr class="separator:ab22e1592de32d13be33edac258085ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b1c9b8654b857c19c725cb27efe83d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4b1c9b8654b857c19c725cb27efe83d"></a>
<a class="el" href="group___d_e_v_i_c_e.html#ga497cdd23c7b282c54f6045552fd1dc3e">device_periph_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ac4b1c9b8654b857c19c725cb27efe83d">periph</a></td></tr>
<tr class="memdesc:ac4b1c9b8654b857c19c725cb27efe83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the configuration used for all peripherals. <br /></td></tr>
<tr class="separator:ac4b1c9b8654b857c19c725cb27efe83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2149072dd41f5ccaeb8da8852b857ee5"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a2149072dd41f5ccaeb8da8852b857ee5">pin_assign</a></td></tr>
<tr class="memdesc:a2149072dd41f5ccaeb8da8852b857ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GPIO pin configuration.  <a href="#a2149072dd41f5ccaeb8da8852b857ee5">More...</a><br /></td></tr>
<tr class="separator:a2149072dd41f5ccaeb8da8852b857ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a2f773d53cdc5238ad60c32589c415"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a96a2f773d53cdc5238ad60c32589c415">bitrate</a></td></tr>
<tr class="memdesc:a96a2f773d53cdc5238ad60c32589c415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the max bit rate in bps.  <a href="#a96a2f773d53cdc5238ad60c32589c415">More...</a><br /></td></tr>
<tr class="separator:a96a2f773d53cdc5238ad60c32589c415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6878248ff22a80e3d890191b023a11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a6878248ff22a80e3d890191b023a11"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a2a6878248ff22a80e3d890191b023a11">dcfg</a></td></tr>
<tr class="memdesc:a2a6878248ff22a80e3d890191b023a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to device specific configuration. <br /></td></tr>
<tr class="separator:a2a6878248ff22a80e3d890191b023a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09138caf0e9776aec440ea0eac5d5b4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09138caf0e9776aec440ea0eac5d5b4a"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a09138caf0e9776aec440ea0eac5d5b4a">state</a></td></tr>
<tr class="memdesc:a09138caf0e9776aec440ea0eac5d5b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to device specific state (RAM) <br /></td></tr>
<tr class="separator:a09138caf0e9776aec440ea0eac5d5b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab797a496c10a8c7de2a8992f1a86208d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab797a496c10a8c7de2a8992f1a86208d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ab797a496c10a8c7de2a8992f1a86208d">tid</a></td></tr>
<tr class="memdesc:ab797a496c10a8c7de2a8992f1a86208d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calling task ID. <br /></td></tr>
<tr class="separator:ab797a496c10a8c7de2a8992f1a86208d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6124217af0a11f104e706859a35a890e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6124217af0a11f104e706859a35a890e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a6124217af0a11f104e706859a35a890e">flags</a></td></tr>
<tr class="memdesc:a6124217af0a11f104e706859a35a890e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The flags for the open file descriptor. <br /></td></tr>
<tr class="separator:a6124217af0a11f104e706859a35a890e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6c2ed1b41972ba62450c7ac341e99a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f6c2ed1b41972ba62450c7ac341e99a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a7f6c2ed1b41972ba62450c7ac341e99a">loc</a></td></tr>
<tr class="memdesc:a7f6c2ed1b41972ba62450c7ac341e99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The location to read or write. <br /></td></tr>
<tr class="separator:a7f6c2ed1b41972ba62450c7ac341e99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd7b63797fbbb4327f396664d340be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fd7b63797fbbb4327f396664d340be7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a6fd7b63797fbbb4327f396664d340be7">nbyte</a></td></tr>
<tr class="memdesc:a6fd7b63797fbbb4327f396664d340be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes to transfer. <br /></td></tr>
<tr class="separator:a6fd7b63797fbbb4327f396664d340be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c462d6ec96dc480ee6c4528542b1d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48c462d6ec96dc480ee6c4528542b1d8"></a>
mcu_callback_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a48c462d6ec96dc480ee6c4528542b1d8">callback</a></td></tr>
<tr class="memdesc:a48c462d6ec96dc480ee6c4528542b1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to call when the operation completes. <br /></td></tr>
<tr class="separator:a48c462d6ec96dc480ee6c4528542b1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c1b9a22cd042c5c6eb42bd136e6812"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30c1b9a22cd042c5c6eb42bd136e6812"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a30c1b9a22cd042c5c6eb42bd136e6812">context</a></td></tr>
<tr class="memdesc:a30c1b9a22cd042c5c6eb42bd136e6812"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first argument to <em>callback</em>. <br /></td></tr>
<tr class="separator:a30c1b9a22cd042c5c6eb42bd136e6812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0baee740959088430dbc19642926dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a0baee740959088430dbc19642926dd"></a>
device_driver_open_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a8a0baee740959088430dbc19642926dd">open</a></td></tr>
<tr class="memdesc:a8a0baee740959088430dbc19642926dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the periph_open() function. <br /></td></tr>
<tr class="separator:a8a0baee740959088430dbc19642926dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73c826a3e694558ce7076bc04b910a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af73c826a3e694558ce7076bc04b910a8"></a>
device_driver_ioctl_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af73c826a3e694558ce7076bc04b910a8">ioctl</a></td></tr>
<tr class="memdesc:af73c826a3e694558ce7076bc04b910a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the periph_ioctl() function. <br /></td></tr>
<tr class="separator:af73c826a3e694558ce7076bc04b910a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc46079acdf051d611e547f01ce656d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc46079acdf051d611e547f01ce656d"></a>
device_driver_read_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a5bc46079acdf051d611e547f01ce656d">read</a></td></tr>
<tr class="memdesc:a5bc46079acdf051d611e547f01ce656d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the periph_read() function. <br /></td></tr>
<tr class="separator:a5bc46079acdf051d611e547f01ce656d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ec5aeb561c02bfce4b38b8c61e0210"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51ec5aeb561c02bfce4b38b8c61e0210"></a>
device_driver_write_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a51ec5aeb561c02bfce4b38b8c61e0210">write</a></td></tr>
<tr class="memdesc:a51ec5aeb561c02bfce4b38b8c61e0210"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the periph_write() function. <br /></td></tr>
<tr class="separator:a51ec5aeb561c02bfce4b38b8c61e0210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c74aeb8c0f9138ea996965845752afd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c74aeb8c0f9138ea996965845752afd"></a>
device_driver_close_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a3c74aeb8c0f9138ea996965845752afd">close</a></td></tr>
<tr class="memdesc:a3c74aeb8c0f9138ea996965845752afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the periph_close() function. <br /></td></tr>
<tr class="separator:a3c74aeb8c0f9138ea996965845752afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf90380ee3287422f73b0fa6bf8dac3"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#afdf90380ee3287422f73b0fa6bf8dac3">name</a> [LINK_NAME_MAX]</td></tr>
<tr class="memdesc:afdf90380ee3287422f73b0fa6bf8dac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device Name.  <a href="#afdf90380ee3287422f73b0fa6bf8dac3">More...</a><br /></td></tr>
<tr class="separator:afdf90380ee3287422f73b0fa6bf8dac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6cd0af2cf678c79be628ecec2e8e43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c6cd0af2cf678c79be628ecec2e8e43"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a2c6cd0af2cf678c79be628ecec2e8e43">flags</a></td></tr>
<tr class="memdesc:a2c6cd0af2cf678c79be628ecec2e8e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">System flags. <br /></td></tr>
<tr class="separator:a2c6cd0af2cf678c79be628ecec2e8e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10128eaba82516c54ffe672392ed08ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10128eaba82516c54ffe672392ed08ec"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a10128eaba82516c54ffe672392ed08ec">mode</a></td></tr>
<tr class="memdesc:a10128eaba82516c54ffe672392ed08ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word width e.g. I2S_WORDWIDTH_16. <br /></td></tr>
<tr class="separator:a10128eaba82516c54ffe672392ed08ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga074f3623d4ee7584c9631b67ec780ef8"><td class="memItemLeft" align="right" valign="top">
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#ga074f3623d4ee7584c9631b67ec780ef8">size</a></td></tr>
<tr class="memdesc:ga074f3623d4ee7584c9631b67ec780ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of <em>mem</em> in bytes (typically w*h/8) <br /></td></tr>
<tr class="separator:ga074f3623d4ee7584c9631b67ec780ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3c28f1638489e9e5b8439a0997e644"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d3c28f1638489e9e5b8439a0997e644"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a7d3c28f1638489e9e5b8439a0997e644">pid</a></td></tr>
<tr class="memdesc:a7d3c28f1638489e9e5b8439a0997e644"><td class="mdescLeft">&#160;</td><td class="mdescRight">PID for the task. <br /></td></tr>
<tr class="separator:a7d3c28f1638489e9e5b8439a0997e644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab797a496c10a8c7de2a8992f1a86208d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab797a496c10a8c7de2a8992f1a86208d"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ab797a496c10a8c7de2a8992f1a86208d">tid</a></td></tr>
<tr class="memdesc:ab797a496c10a8c7de2a8992f1a86208d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task ID. <br /></td></tr>
<tr class="separator:ab797a496c10a8c7de2a8992f1a86208d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007389805fd6b8775bf36778eb63e276"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a007389805fd6b8775bf36778eb63e276">mem_loc</a></td></tr>
<tr class="memdesc:a007389805fd6b8775bf36778eb63e276"><td class="mdescLeft">&#160;</td><td class="mdescRight">location of data memory  <a href="#a007389805fd6b8775bf36778eb63e276">More...</a><br /></td></tr>
<tr class="separator:a007389805fd6b8775bf36778eb63e276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f503ae9705f834143f76d4647af754"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a23f503ae9705f834143f76d4647af754">mem_size</a></td></tr>
<tr class="memdesc:a23f503ae9705f834143f76d4647af754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of data memory.  <a href="#a23f503ae9705f834143f76d4647af754">More...</a><br /></td></tr>
<tr class="separator:a23f503ae9705f834143f76d4647af754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29a1317fad39261e25287ca2c04dde8"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ae29a1317fad39261e25287ca2c04dde8">malloc_loc</a></td></tr>
<tr class="memdesc:ae29a1317fad39261e25287ca2c04dde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">malloc base + size  <a href="#ae29a1317fad39261e25287ca2c04dde8">More...</a><br /></td></tr>
<tr class="separator:ae29a1317fad39261e25287ca2c04dde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4922498206deedf973ddc18e8f3d9f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a3e4922498206deedf973ddc18e8f3d9f">stack_ptr</a></td></tr>
<tr class="memdesc:a3e4922498206deedf973ddc18e8f3d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">location of stack pointer  <a href="#a3e4922498206deedf973ddc18e8f3d9f">More...</a><br /></td></tr>
<tr class="separator:a3e4922498206deedf973ddc18e8f3d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422ad984416035b844e2ca655e27ba62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a422ad984416035b844e2ca655e27ba62"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a422ad984416035b844e2ca655e27ba62">prio</a></td></tr>
<tr class="memdesc:a422ad984416035b844e2ca655e27ba62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task Priority. <br /></td></tr>
<tr class="separator:a422ad984416035b844e2ca655e27ba62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b780565bdfc71dc7bc866a109a9c071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b780565bdfc71dc7bc866a109a9c071"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a9b780565bdfc71dc7bc866a109a9c071">prio_ceiling</a></td></tr>
<tr class="memdesc:a9b780565bdfc71dc7bc866a109a9c071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task priority ceiling. <br /></td></tr>
<tr class="separator:a9b780565bdfc71dc7bc866a109a9c071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8051a8f0430c1dc2282dea75248f3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f8051a8f0430c1dc2282dea75248f3a"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a1f8051a8f0430c1dc2282dea75248f3a">is_active</a></td></tr>
<tr class="memdesc:a1f8051a8f0430c1dc2282dea75248f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-zero for an active task. <br /></td></tr>
<tr class="separator:a1f8051a8f0430c1dc2282dea75248f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c7d11c406e238b298337dc7f2b6306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70c7d11c406e238b298337dc7f2b6306"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a70c7d11c406e238b298337dc7f2b6306">is_thread</a></td></tr>
<tr class="memdesc:a70c7d11c406e238b298337dc7f2b6306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-zero if not main process thread. <br /></td></tr>
<tr class="separator:a70c7d11c406e238b298337dc7f2b6306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035f9ff89246f0093009e750f822d8cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a035f9ff89246f0093009e750f822d8cc"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a035f9ff89246f0093009e750f822d8cc">is_enabled</a></td></tr>
<tr class="memdesc:a035f9ff89246f0093009e750f822d8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-zero if associated with running process. <br /></td></tr>
<tr class="separator:a035f9ff89246f0093009e750f822d8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dcabe654420d0afe4888912763378f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16dcabe654420d0afe4888912763378f"></a>
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a16dcabe654420d0afe4888912763378f">enabled_channels</a></td></tr>
<tr class="memdesc:a16dcabe654420d0afe4888912763378f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mask of the enabled channels (a one means the channel is enabled) <br /></td></tr>
<tr class="separator:a16dcabe654420d0afe4888912763378f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad923b38588d7a4dc2700db170e172bf5"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#gad923b38588d7a4dc2700db170e172bf5">freq</a></td></tr>
<tr class="memdesc:gad923b38588d7a4dc2700db170e172bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The read update frequency (can't be zero). This is a target value when writing and the actual value when reading.  <a href="group___m_l_c_d.html#gad923b38588d7a4dc2700db170e172bf5">More...</a><br /></td></tr>
<tr class="separator:gad923b38588d7a4dc2700db170e172bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af713f6486290d4d7021b5ed94fa90205"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af713f6486290d4d7021b5ed94fa90205"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af713f6486290d4d7021b5ed94fa90205">version</a></td></tr>
<tr class="memdesc:af713f6486290d4d7021b5ed94fa90205"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bootloader version. <br /></td></tr>
<tr class="separator:af713f6486290d4d7021b5ed94fa90205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea17ed24535aac5c6c292518f6ba34f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ea17ed24535aac5c6c292518f6ba34f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a4ea17ed24535aac5c6c292518f6ba34f">serialno</a> [4]</td></tr>
<tr class="memdesc:a4ea17ed24535aac5c6c292518f6ba34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device serial number. <br /></td></tr>
<tr class="separator:a4ea17ed24535aac5c6c292518f6ba34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95b5327e7fd614c64779b93a983773d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad95b5327e7fd614c64779b93a983773d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ad95b5327e7fd614c64779b93a983773d">startaddr</a></td></tr>
<tr class="memdesc:ad95b5327e7fd614c64779b93a983773d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The start address of the target program (read-only) <br /></td></tr>
<tr class="separator:ad95b5327e7fd614c64779b93a983773d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94914f9ef84e2f7f0174fab53f39aa07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94914f9ef84e2f7f0174fab53f39aa07"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a94914f9ef84e2f7f0174fab53f39aa07">hardware_id</a></td></tr>
<tr class="memdesc:a94914f9ef84e2f7f0174fab53f39aa07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The hardware ID of the bootloader (must match image) <br /></td></tr>
<tr class="separator:a94914f9ef84e2f7f0174fab53f39aa07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f248c3e0c27d58a8425430427091e0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af2f248c3e0c27d58a8425430427091e0">addr</a></td></tr>
<tr class="memdesc:af2f248c3e0c27d58a8425430427091e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address to write to.  <a href="#af2f248c3e0c27d58a8425430427091e0">More...</a><br /></td></tr>
<tr class="separator:af2f248c3e0c27d58a8425430427091e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8f700c9c19061a85130b8e6eb54409"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#afe8f700c9c19061a85130b8e6eb54409">nbyte</a></td></tr>
<tr class="memdesc:afe8f700c9c19061a85130b8e6eb54409"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes to write.  <a href="#afe8f700c9c19061a85130b8e6eb54409">More...</a><br /></td></tr>
<tr class="separator:afe8f700c9c19061a85130b8e6eb54409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b40b25b04ccb3572b25aec82cd3221"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9b40b25b04ccb3572b25aec82cd3221"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af9b40b25b04ccb3572b25aec82cd3221">buf</a> [<a class="el" href="group___b_o_o_t_l_o_a_d_e_r___d_e_v.html#ga19c84e227663f805698c397c2d4399a7">BOOTLOADER_WRITEPAGESIZE</a>]</td></tr>
<tr class="memdesc:af9b40b25b04ccb3572b25aec82cd3221"><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer for writing to the flash. <br /></td></tr>
<tr class="separator:af9b40b25b04ccb3572b25aec82cd3221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d567c5501e4f70ebbc0b7ed596a1a3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d567c5501e4f70ebbc0b7ed596a1a3b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a8d567c5501e4f70ebbc0b7ed596a1a3b">src</a></td></tr>
<tr class="memdesc:a8d567c5501e4f70ebbc0b7ed596a1a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The clock output source (see <a class="el" href="group___c_o_r_e.html#ga865263eb03a43700297f3eba0c085b88">core_clkout_src_t</a>) <br /></td></tr>
<tr class="separator:a8d567c5501e4f70ebbc0b7ed596a1a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80207d5a8ebc45d45548560a80754b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae80207d5a8ebc45d45548560a80754b7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ae80207d5a8ebc45d45548560a80754b7">div</a></td></tr>
<tr class="memdesc:ae80207d5a8ebc45d45548560a80754b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The clock divide value applied to src. <br /></td></tr>
<tr class="separator:ae80207d5a8ebc45d45548560a80754b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bb317169681ca8331f98618a8d971a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4bb317169681ca8331f98618a8d971a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aa4bb317169681ca8331f98618a8d971a">serial_number</a> [4]</td></tr>
<tr class="memdesc:aa4bb317169681ca8331f98618a8d971a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The serial number of the device (from the silicon) <br /></td></tr>
<tr class="separator:aa4bb317169681ca8331f98618a8d971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab246af8d91abf524ec283d6e5363a657"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ab246af8d91abf524ec283d6e5363a657">clock</a></td></tr>
<tr class="memdesc:ab246af8d91abf524ec283d6e5363a657"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current clock speed.  <a href="#ab246af8d91abf524ec283d6e5363a657">More...</a><br /></td></tr>
<tr class="separator:ab246af8d91abf524ec283d6e5363a657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b8f0b68e3350c5e1651e8ba876cf9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8b8f0b68e3350c5e1651e8ba876cf9f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ae8b8f0b68e3350c5e1651e8ba876cf9f">signature</a></td></tr>
<tr class="memdesc:ae8b8f0b68e3350c5e1651e8ba876cf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The software signature. <br /></td></tr>
<tr class="separator:ae8b8f0b68e3350c5e1651e8ba876cf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddb9c27cd02035883a549a04c8711b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ddb9c27cd02035883a549a04c8711b6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a6ddb9c27cd02035883a549a04c8711b6">reset_type</a></td></tr>
<tr class="memdesc:a6ddb9c27cd02035883a549a04c8711b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The source of the last reset. <br /></td></tr>
<tr class="separator:a6ddb9c27cd02035883a549a04c8711b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867bf458f32395fc2def8a277e5fc34f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a867bf458f32395fc2def8a277e5fc34f"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a867bf458f32395fc2def8a277e5fc34f">periph_port</a></td></tr>
<tr class="memdesc:a867bf458f32395fc2def8a277e5fc34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peripheral port value (e.g. 0 for I2C0) <br /></td></tr>
<tr class="separator:a867bf458f32395fc2def8a277e5fc34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47952177cb3908447df2d2e7a12d1a8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47952177cb3908447df2d2e7a12d1a8d"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a47952177cb3908447df2d2e7a12d1a8d">periph_func</a></td></tr>
<tr class="memdesc:a47952177cb3908447df2d2e7a12d1a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peripheral port function (see <a class="el" href="group___c_o_r_e.html#ga0cdc50382b3b72c2e4b983c2f2a6f99b">core_periph_t</a>) <br /></td></tr>
<tr class="separator:a47952177cb3908447df2d2e7a12d1a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af423413e1d9655d50532179b710df711"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af423413e1d9655d50532179b710df711"></a>
<a class="el" href="group___p_i_o.html#gaf8578727d6d1ca42e649beec21752b0a">pio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af423413e1d9655d50532179b710df711">io</a></td></tr>
<tr class="memdesc:af423413e1d9655d50532179b710df711"><td class="mdescLeft">&#160;</td><td class="mdescRight">PIO port and pin (see <a class="el" href="group___p_i_o.html#gaf8578727d6d1ca42e649beec21752b0a">pio_t</a>) <br /></td></tr>
<tr class="separator:af423413e1d9655d50532179b710df711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bd0113ac5e9a4527b195f0d9487a70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6bd0113ac5e9a4527b195f0d9487a70"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ab6bd0113ac5e9a4527b195f0d9487a70">periph</a></td></tr>
<tr class="memdesc:ab6bd0113ac5e9a4527b195f0d9487a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">The peripheral type (see <a class="el" href="group___c_o_r_e.html#ga0cdc50382b3b72c2e4b983c2f2a6f99b">core_periph_t</a>) <br /></td></tr>
<tr class="separator:ab6bd0113ac5e9a4527b195f0d9487a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe69dcbd64314a3331e515b2952072a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe69dcbd64314a3331e515b2952072a6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#abe69dcbd64314a3331e515b2952072a6">prio</a></td></tr>
<tr class="memdesc:abe69dcbd64314a3331e515b2952072a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The priority (lower number is higher priority on ARM CM3. <br /></td></tr>
<tr class="separator:abe69dcbd64314a3331e515b2952072a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6795fa0655d0a550c9632aee512d87"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a7c6795fa0655d0a550c9632aee512d87">port</a></td></tr>
<tr class="memdesc:a7c6795fa0655d0a550c9632aee512d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The peripheral port number (e.g. 0 for I2C0)  <a href="#a7c6795fa0655d0a550c9632aee512d87">More...</a><br /></td></tr>
<tr class="separator:a7c6795fa0655d0a550c9632aee512d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa028043000bdd4d9681a0d89e7774222"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aa028043000bdd4d9681a0d89e7774222">pin_assign</a></td></tr>
<tr class="memdesc:aa028043000bdd4d9681a0d89e7774222"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GPIO configuration to use (see LPC17XXDEV)  <a href="#aa028043000bdd4d9681a0d89e7774222">More...</a><br /></td></tr>
<tr class="separator:aa028043000bdd4d9681a0d89e7774222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486039ac6cb55ec414a703a66a9a7538"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a486039ac6cb55ec414a703a66a9a7538">enabled_channels</a></td></tr>
<tr class="memdesc:a486039ac6cb55ec414a703a66a9a7538"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DAC channels to enable.  <a href="#a486039ac6cb55ec414a703a66a9a7538">More...</a><br /></td></tr>
<tr class="separator:a486039ac6cb55ec414a703a66a9a7538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdeb83df08c04b23c15272f641797fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a5fdeb83df08c04b23c15272f641797fd">freq</a></td></tr>
<tr class="memdesc:a5fdeb83df08c04b23c15272f641797fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output frequency.  <a href="#a5fdeb83df08c04b23c15272f641797fd">More...</a><br /></td></tr>
<tr class="separator:a5fdeb83df08c04b23c15272f641797fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074f3623d4ee7584c9631b67ec780ef8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a074f3623d4ee7584c9631b67ec780ef8">size</a></td></tr>
<tr class="memdesc:a074f3623d4ee7584c9631b67ec780ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of bytes in the FIFO.  <a href="#a074f3623d4ee7584c9631b67ec780ef8">More...</a><br /></td></tr>
<tr class="separator:a074f3623d4ee7584c9631b67ec780ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacbce886acf2fe356623dc18caec7c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abacbce886acf2fe356623dc18caec7c9"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#abacbce886acf2fe356623dc18caec7c9">used</a></td></tr>
<tr class="memdesc:abacbce886acf2fe356623dc18caec7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes ready to be read from the FIFO. <br /></td></tr>
<tr class="separator:abacbce886acf2fe356623dc18caec7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954b1b0e5c94552b4febf2ef9d7063a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a954b1b0e5c94552b4febf2ef9d7063a9">overflow</a></td></tr>
<tr class="memdesc:a954b1b0e5c94552b4febf2ef9d7063a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-zero if FIFO has dropped data because data is arriving faster than it is being read; this value is cleared when it is read using I_DEVFIFO_GETATTR.  <a href="#a954b1b0e5c94552b4febf2ef9d7063a9">More...</a><br /></td></tr>
<tr class="separator:a954b1b0e5c94552b4febf2ef9d7063a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dabe61cb1dfc52982678b126f035ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76dabe61cb1dfc52982678b126f035ea"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a76dabe61cb1dfc52982678b126f035ea">start</a></td></tr>
<tr class="memdesc:a76dabe61cb1dfc52982678b126f035ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">First block to erase. <br /></td></tr>
<tr class="separator:a76dabe61cb1dfc52982678b126f035ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229d5f14c48521b74564bca2b571098"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4229d5f14c48521b74564bca2b571098"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a4229d5f14c48521b74564bca2b571098">end</a></td></tr>
<tr class="memdesc:a4229d5f14c48521b74564bca2b571098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last block to erase. <br /></td></tr>
<tr class="separator:a4229d5f14c48521b74564bca2b571098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade4b00a2da457a729a9bcc7f4d82027"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aade4b00a2da457a729a9bcc7f4d82027"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aade4b00a2da457a729a9bcc7f4d82027">address_size</a></td></tr>
<tr class="memdesc:aade4b00a2da457a729a9bcc7f4d82027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes per address location (1 for small devices 512 for larger ones. <br /></td></tr>
<tr class="separator:aade4b00a2da457a729a9bcc7f4d82027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76bd432b24427118d0a022d467e91ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa76bd432b24427118d0a022d467e91ae"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aa76bd432b24427118d0a022d467e91ae">write_block_size</a></td></tr>
<tr class="memdesc:aa76bd432b24427118d0a022d467e91ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum write block size. <br /></td></tr>
<tr class="separator:aa76bd432b24427118d0a022d467e91ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e12333eb3cae455a7231b118f0e60ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e12333eb3cae455a7231b118f0e60ca"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a7e12333eb3cae455a7231b118f0e60ca">num_write_blocks</a></td></tr>
<tr class="memdesc:a7e12333eb3cae455a7231b118f0e60ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of write blocks (size is num_write_blocks*write_block_size. <br /></td></tr>
<tr class="separator:a7e12333eb3cae455a7231b118f0e60ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c9ac58d3f8a817413ea61c6f5cb330"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01c9ac58d3f8a817413ea61c6f5cb330"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a01c9ac58d3f8a817413ea61c6f5cb330">erase_block_size</a></td></tr>
<tr class="memdesc:a01c9ac58d3f8a817413ea61c6f5cb330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum eraseable block size. <br /></td></tr>
<tr class="separator:a01c9ac58d3f8a817413ea61c6f5cb330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae7a07f4bfe72b874d5a441581da7f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ae7a07f4bfe72b874d5a441581da7f4"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a5ae7a07f4bfe72b874d5a441581da7f4">erase_block_time</a></td></tr>
<tr class="memdesc:a5ae7a07f4bfe72b874d5a441581da7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time in microseconds to erase one block. <br /></td></tr>
<tr class="separator:a5ae7a07f4bfe72b874d5a441581da7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4989c9bc4ff45bac0b45a4e7cc731b56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4989c9bc4ff45bac0b45a4e7cc731b56"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a4989c9bc4ff45bac0b45a4e7cc731b56">erase_device_time</a></td></tr>
<tr class="memdesc:a4989c9bc4ff45bac0b45a4e7cc731b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time in microseconds to erase the device. <br /></td></tr>
<tr class="separator:a4989c9bc4ff45bac0b45a4e7cc731b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29f4c0bdd78f0c5e23e835689ef60b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ae29f4c0bdd78f0c5e23e835689ef60b5">bitrate</a></td></tr>
<tr class="memdesc:ae29f4c0bdd78f0c5e23e835689ef60b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max bitrate.  <a href="#ae29f4c0bdd78f0c5e23e835689ef60b5">More...</a><br /></td></tr>
<tr class="separator:ae29f4c0bdd78f0c5e23e835689ef60b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1730b32f7df668f2ecd2508877651d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed1730b32f7df668f2ecd2508877651d"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aed1730b32f7df668f2ecd2508877651d">value</a></td></tr>
<tr class="memdesc:aed1730b32f7df668f2ecd2508877651d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of input at pin (1 for high and zero for low) <br /></td></tr>
<tr class="separator:aed1730b32f7df668f2ecd2508877651d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfe4f3f8c637cbcba6be0513409bf8e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a2bfe4f3f8c637cbcba6be0513409bf8e">mode</a></td></tr>
<tr class="memdesc:a2bfe4f3f8c637cbcba6be0513409bf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pin mode for pulling up/down/float.  <a href="#a2bfe4f3f8c637cbcba6be0513409bf8e">More...</a><br /></td></tr>
<tr class="separator:a2bfe4f3f8c637cbcba6be0513409bf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709351c6a480e8102b480fcf150fdfd7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a709351c6a480e8102b480fcf150fdfd7">channel</a></td></tr>
<tr class="memdesc:a709351c6a480e8102b480fcf150fdfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The channel.  <a href="#a709351c6a480e8102b480fcf150fdfd7">More...</a><br /></td></tr>
<tr class="separator:a709351c6a480e8102b480fcf150fdfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503ac64fde9d1ca872ec66d88450f704"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a503ac64fde9d1ca872ec66d88450f704">wait_write_enable</a></td></tr>
<tr class="separator:a503ac64fde9d1ca872ec66d88450f704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb93a3edf045975a50a95b4a0060468"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aeeb93a3edf045975a50a95b4a0060468">wait_output_enable</a></td></tr>
<tr class="separator:aeeb93a3edf045975a50a95b4a0060468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f2f813a5c964bc286615f1db7268dc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a73f2f813a5c964bc286615f1db7268dc">wait_rd</a></td></tr>
<tr class="separator:a73f2f813a5c964bc286615f1db7268dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba89b554fe49fd80e70b88138c554c67"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aba89b554fe49fd80e70b88138c554c67">wait_page</a></td></tr>
<tr class="separator:aba89b554fe49fd80e70b88138c554c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e48f6059859b58c073348d7a47c9ef"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a62e48f6059859b58c073348d7a47c9ef">wait_wr</a></td></tr>
<tr class="separator:a62e48f6059859b58c073348d7a47c9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a3775345eca1f709956965ad3ca62e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a91a3775345eca1f709956965ad3ca62e">wait_turn</a></td></tr>
<tr class="separator:a91a3775345eca1f709956965ad3ca62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28d23864fa60f3af2ad871840ba1970"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ae28d23864fa60f3af2ad871840ba1970">addr_width</a></td></tr>
<tr class="separator:ae28d23864fa60f3af2ad871840ba1970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db29d3536c45e8f321898f125fc54dc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a1db29d3536c45e8f321898f125fc54dc">mode</a></td></tr>
<tr class="memdesc:a1db29d3536c45e8f321898f125fc54dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full duplex mode setting.  <a href="#a1db29d3536c45e8f321898f125fc54dc">More...</a><br /></td></tr>
<tr class="separator:a1db29d3536c45e8f321898f125fc54dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac296e6de49f6fb5c29eaaaa0f54cb1b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac296e6de49f6fb5c29eaaaa0f54cb1b4"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ac296e6de49f6fb5c29eaaaa0f54cb1b4">flags</a></td></tr>
<tr class="memdesc:ac296e6de49f6fb5c29eaaaa0f54cb1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag settings (see ENET_FLAGS_*) <br /></td></tr>
<tr class="separator:ac296e6de49f6fb5c29eaaaa0f54cb1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b799bbdb1d0699da4d3ee28114d1a08"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a4b799bbdb1d0699da4d3ee28114d1a08">mac_addr</a> [6]</td></tr>
<tr class="memdesc:a4b799bbdb1d0699da4d3ee28114d1a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">MAC address.  <a href="#a4b799bbdb1d0699da4d3ee28114d1a08">More...</a><br /></td></tr>
<tr class="separator:a4b799bbdb1d0699da4d3ee28114d1a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a433f7f82dcdc7d15d97d51b8b02745"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_i_o.html#ga9a433f7f82dcdc7d15d97d51b8b02745">count</a></td></tr>
<tr class="memdesc:ga9a433f7f82dcdc7d15d97d51b8b02745"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of values in the descriptor.  <a href="group___h_i_o.html#ga9a433f7f82dcdc7d15d97d51b8b02745">More...</a><br /></td></tr>
<tr class="separator:ga9a433f7f82dcdc7d15d97d51b8b02745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2ba7bbd997bebb5460ff124f66d591"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b2ba7bbd997bebb5460ff124f66d591"></a>
ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a5b2ba7bbd997bebb5460ff124f66d591">loc</a></td></tr>
<tr class="memdesc:a5b2ba7bbd997bebb5460ff124f66d591"><td class="mdescLeft">&#160;</td><td class="mdescRight">The location to peek. <br /></td></tr>
<tr class="separator:a5b2ba7bbd997bebb5460ff124f66d591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b585ae287033bf47afc95dc000c6307"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b585ae287033bf47afc95dc000c6307"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a1b585ae287033bf47afc95dc000c6307">buf</a></td></tr>
<tr class="memdesc:a1b585ae287033bf47afc95dc000c6307"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the buffer to receive peek bytes. <br /></td></tr>
<tr class="separator:a1b585ae287033bf47afc95dc000c6307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ed75b60f84b241966358511827db3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9ed75b60f84b241966358511827db3f"></a>
ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af9ed75b60f84b241966358511827db3f">nbyte</a></td></tr>
<tr class="memdesc:af9ed75b60f84b241966358511827db3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes to peek. <br /></td></tr>
<tr class="separator:af9ed75b60f84b241966358511827db3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120e1cfd95ec1d286b3cca6312c6b76c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a120e1cfd95ec1d286b3cca6312c6b76c"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a120e1cfd95ec1d286b3cca6312c6b76c">buffer</a></td></tr>
<tr class="memdesc:a120e1cfd95ec1d286b3cca6312c6b76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the buffer. <br /></td></tr>
<tr class="separator:a120e1cfd95ec1d286b3cca6312c6b76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acbcf87d3fe5e786d4f1f04c6bad271"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3acbcf87d3fe5e786d4f1f04c6bad271"></a>
<a class="el" href="group___g_p_i_o.html#gad5bba12d58022b010776d35cc964a4f8">gpio_sample_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a3acbcf87d3fe5e786d4f1f04c6bad271">output</a></td></tr>
<tr class="memdesc:a3acbcf87d3fe5e786d4f1f04c6bad271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bits set here will configure the corresponding pins as GPIO outputs. <br /></td></tr>
<tr class="separator:a3acbcf87d3fe5e786d4f1f04c6bad271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4919dcabe4d04e2365f16e1d1bcfeec9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4919dcabe4d04e2365f16e1d1bcfeec9"></a>
<a class="el" href="group___g_p_i_o.html#gad5bba12d58022b010776d35cc964a4f8">gpio_sample_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a4919dcabe4d04e2365f16e1d1bcfeec9">input</a></td></tr>
<tr class="memdesc:a4919dcabe4d04e2365f16e1d1bcfeec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bits set here will configure the corresponding pins as GPIO inputs. <br /></td></tr>
<tr class="separator:a4919dcabe4d04e2365f16e1d1bcfeec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef48949d506fd6a73fcaf2e1cb2cedb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ef48949d506fd6a73fcaf2e1cb2cedb"></a>
<a class="el" href="group___g_p_i_o.html#ga58afe68d92f686031ea2bfa3d8e30386">gpio_pinmode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a8ef48949d506fd6a73fcaf2e1cb2cedb">mode</a></td></tr>
<tr class="memdesc:a8ef48949d506fd6a73fcaf2e1cb2cedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mode to use. <br /></td></tr>
<tr class="separator:a8ef48949d506fd6a73fcaf2e1cb2cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa986f17ba1264996f6b914fcffaee05e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa986f17ba1264996f6b914fcffaee05e"></a>
<a class="el" href="group___g_p_i_o.html#gad5bba12d58022b010776d35cc964a4f8">gpio_sample_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aa986f17ba1264996f6b914fcffaee05e">mask</a></td></tr>
<tr class="memdesc:aa986f17ba1264996f6b914fcffaee05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each bit set in the mask will be set to <em>mode</em> using I_GPIO_SET_PINMODE. <br /></td></tr>
<tr class="separator:aa986f17ba1264996f6b914fcffaee05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291bd7ced313183f7fc15e48d1586b4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a291bd7ced313183f7fc15e48d1586b4a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a291bd7ced313183f7fc15e48d1586b4a">opendrain</a></td></tr>
<tr class="memdesc:a291bd7ced313183f7fc15e48d1586b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not pin should be configured as an open drain. <br /></td></tr>
<tr class="separator:a291bd7ced313183f7fc15e48d1586b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac84bfe56c1e681e92142f447d1f410"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ac84bfe56c1e681e92142f447d1f410"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a0ac84bfe56c1e681e92142f447d1f410">hysteresis</a></td></tr>
<tr class="memdesc:a0ac84bfe56c1e681e92142f447d1f410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not to enable hysteresis on this pin (if supported) <br /></td></tr>
<tr class="separator:a0ac84bfe56c1e681e92142f447d1f410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff1eaaa3781474e219dad215885e5fd6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_i_o.html#gaff1eaaa3781474e219dad215885e5fd6">type</a></td></tr>
<tr class="memdesc:gaff1eaaa3781474e219dad215885e5fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of data (ie HIO_TYPE_UINT8)  <a href="group___h_i_o.html#gaff1eaaa3781474e219dad215885e5fd6">More...</a><br /></td></tr>
<tr class="separator:gaff1eaaa3781474e219dad215885e5fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c6aea13d242d984fa28eac6bfce153"><td class="memItemLeft" align="right" valign="top">
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_i_o.html#ga90c6aea13d242d984fa28eac6bfce153">use</a></td></tr>
<tr class="memdesc:ga90c6aea13d242d984fa28eac6bfce153"><td class="mdescLeft">&#160;</td><td class="mdescRight">How the data is used (such as a button input, or LED) <br /></td></tr>
<tr class="separator:ga90c6aea13d242d984fa28eac6bfce153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f9d04b5e9c75e6f1014e04b64dae602"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="group___h_i_o.html#ga7cb54eb5ea4049768017863ddc252393">hio_desc_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_i_o.html#ga0f9d04b5e9c75e6f1014e04b64dae602">report_desc</a></td></tr>
<tr class="memdesc:ga0f9d04b5e9c75e6f1014e04b64dae602"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the HIO report descriptor. <br /></td></tr>
<tr class="separator:ga0f9d04b5e9c75e6f1014e04b64dae602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f4cc2f37cc753b8209ac45f88592948"><td class="memItemLeft" align="right" valign="top">
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_i_o.html#ga5f4cc2f37cc753b8209ac45f88592948">size</a></td></tr>
<tr class="memdesc:ga5f4cc2f37cc753b8209ac45f88592948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of the report. <br /></td></tr>
<tr class="separator:ga5f4cc2f37cc753b8209ac45f88592948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bf03a5e4f42fab46376b06707694c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97bf03a5e4f42fab46376b06707694c1"></a>
<a class="el" href="group___i2_c.html#ga3ad96dadad63bfad13256b053c868ac3">i2c_transfer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a97bf03a5e4f42fab46376b06707694c1">transfer</a></td></tr>
<tr class="memdesc:a97bf03a5e4f42fab46376b06707694c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The I2C transfer type. <br /></td></tr>
<tr class="separator:a97bf03a5e4f42fab46376b06707694c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa395e6fac189f411ad1d2200171f948a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa395e6fac189f411ad1d2200171f948a"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aa395e6fac189f411ad1d2200171f948a">slave_addr</a></td></tr>
<tr class="memdesc:aa395e6fac189f411ad1d2200171f948a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The slave address. <br /></td></tr>
<tr class="separator:aa395e6fac189f411ad1d2200171f948a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3cf8c88a5ef05f2461400a4e4381b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d3cf8c88a5ef05f2461400a4e4381b5"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a7d3cf8c88a5ef05f2461400a4e4381b5">frequency</a></td></tr>
<tr class="memdesc:a7d3cf8c88a5ef05f2461400a4e4381b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The I2S audio frequency. <br /></td></tr>
<tr class="separator:a7d3cf8c88a5ef05f2461400a4e4381b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27c3913fced446d2ace4e258b5ce02b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af27c3913fced446d2ace4e258b5ce02b"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af27c3913fced446d2ace4e258b5ce02b">block_size</a></td></tr>
<tr class="memdesc:af27c3913fced446d2ace4e258b5ce02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block size of card. <br /></td></tr>
<tr class="separator:af27c3913fced446d2ace4e258b5ce02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e29a3f781dc6837658be3e8202e65e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e29a3f781dc6837658be3e8202e65e5"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a2e29a3f781dc6837658be3e8202e65e5">flash_pages</a></td></tr>
<tr class="memdesc:a2e29a3f781dc6837658be3e8202e65e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of flash pages. <br /></td></tr>
<tr class="separator:a2e29a3f781dc6837658be3e8202e65e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1ab8a4155f993f763e4a7560cfda8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c1ab8a4155f993f763e4a7560cfda8c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a3c1ab8a4155f993f763e4a7560cfda8c">flash_size</a></td></tr>
<tr class="memdesc:a3c1ab8a4155f993f763e4a7560cfda8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total size of the flash memory. <br /></td></tr>
<tr class="separator:a3c1ab8a4155f993f763e4a7560cfda8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5da3ca0c4088ceff57cff67a5248ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c5da3ca0c4088ceff57cff67a5248ea"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a3c5da3ca0c4088ceff57cff67a5248ea">ram_pages</a></td></tr>
<tr class="memdesc:a3c5da3ca0c4088ceff57cff67a5248ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of RAM pages. <br /></td></tr>
<tr class="separator:a3c5da3ca0c4088ceff57cff67a5248ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf36ff8f1ccf2d0c782ec28d08fe62dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf36ff8f1ccf2d0c782ec28d08fe62dd"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aaf36ff8f1ccf2d0c782ec28d08fe62dd">ram_size</a></td></tr>
<tr class="memdesc:aaf36ff8f1ccf2d0c782ec28d08fe62dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total size of the RAM. <br /></td></tr>
<tr class="separator:aaf36ff8f1ccf2d0c782ec28d08fe62dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca9e5b322cc6699aaaabf9d1952d62d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ca9e5b322cc6699aaaabf9d1952d62d"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a5ca9e5b322cc6699aaaabf9d1952d62d">num</a></td></tr>
<tr class="memdesc:a5ca9e5b322cc6699aaaabf9d1952d62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the page number <br /></td></tr>
<tr class="separator:a5ca9e5b322cc6699aaaabf9d1952d62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40120b1d53c5328bab0a3ded4f53efb9"><td class="memItemLeft" align="right" valign="top">
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#ga40120b1d53c5328bab0a3ded4f53efb9">w</a></td></tr>
<tr class="memdesc:ga40120b1d53c5328bab0a3ded4f53efb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">LCD width in pixels. <br /></td></tr>
<tr class="separator:ga40120b1d53c5328bab0a3ded4f53efb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa332e40cf29484c5641d27b3bef5c9ce"><td class="memItemLeft" align="right" valign="top">
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#gaa332e40cf29484c5641d27b3bef5c9ce">h</a></td></tr>
<tr class="memdesc:gaa332e40cf29484c5641d27b3bef5c9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">LCD height in pixels. <br /></td></tr>
<tr class="separator:gaa332e40cf29484c5641d27b3bef5c9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5934443412e9be5b2dcd79c68e2e50e"><td class="memItemLeft" align="right" valign="top">
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#gaf5934443412e9be5b2dcd79c68e2e50e">cols</a></td></tr>
<tr class="memdesc:gaf5934443412e9be5b2dcd79c68e2e50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of memory 32-bit word columns. <br /></td></tr>
<tr class="separator:gaf5934443412e9be5b2dcd79c68e2e50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07471923d8ffc2111c949934695190de"><td class="memItemLeft" align="right" valign="top">
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#ga07471923d8ffc2111c949934695190de">rows</a></td></tr>
<tr class="memdesc:ga07471923d8ffc2111c949934695190de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of memory rows. <br /></td></tr>
<tr class="separator:ga07471923d8ffc2111c949934695190de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa6f7020762fa416e4944f26ab2579a"><td class="memItemLeft" align="right" valign="top">
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#gaaaa6f7020762fa416e4944f26ab2579a">hold</a></td></tr>
<tr class="memdesc:gaaaa6f7020762fa416e4944f26ab2579a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This values specifies the hold count. A non-zero hold count prevents the screen from refreshing. <br /></td></tr>
<tr class="separator:gaaaa6f7020762fa416e4944f26ab2579a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8b088d9a07ec5b1272d30b27b4456f"><td class="memItemLeft" align="right" valign="top">
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#gafc8b088d9a07ec5b1272d30b27b4456f">orientation</a></td></tr>
<tr class="memdesc:gafc8b088d9a07ec5b1272d30b27b4456f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orientation bitmask. <br /></td></tr>
<tr class="separator:gafc8b088d9a07ec5b1272d30b27b4456f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26670eb62bb8bc555f2ce2a8ff875d7c"><td class="memItemLeft" align="right" valign="top">
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#ga26670eb62bb8bc555f2ce2a8ff875d7c">margin_left</a></td></tr>
<tr class="memdesc:ga26670eb62bb8bc555f2ce2a8ff875d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left margin. <br /></td></tr>
<tr class="separator:ga26670eb62bb8bc555f2ce2a8ff875d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42c81d200cfac323c035cab235be9ce4"><td class="memItemLeft" align="right" valign="top">
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#ga42c81d200cfac323c035cab235be9ce4">margin_right</a></td></tr>
<tr class="memdesc:ga42c81d200cfac323c035cab235be9ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left margin. <br /></td></tr>
<tr class="separator:ga42c81d200cfac323c035cab235be9ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d86e3688d98eca9f412817aae71f29b"><td class="memItemLeft" align="right" valign="top">
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#ga9d86e3688d98eca9f412817aae71f29b">margin_top</a></td></tr>
<tr class="memdesc:ga9d86e3688d98eca9f412817aae71f29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left margin. <br /></td></tr>
<tr class="separator:ga9d86e3688d98eca9f412817aae71f29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390f8e3dc1a2b757ad72c3bbb174f1fd"><td class="memItemLeft" align="right" valign="top">
u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_l_c_d.html#ga390f8e3dc1a2b757ad72c3bbb174f1fd">margin_bottom</a></td></tr>
<tr class="memdesc:ga390f8e3dc1a2b757ad72c3bbb174f1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left margin. <br /></td></tr>
<tr class="separator:ga390f8e3dc1a2b757ad72c3bbb174f1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7fae11bd5df4f866310f9848a237ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b7fae11bd5df4f866310f9848a237ad"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a3b7fae11bd5df4f866310f9848a237ad">pin</a></td></tr>
<tr class="memdesc:a3b7fae11bd5df4f866310f9848a237ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pin number. <br /></td></tr>
<tr class="separator:a3b7fae11bd5df4f866310f9848a237ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9c8e590392068724f06fee015ecbe7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b9c8e590392068724f06fee015ecbe7"></a>
<a class="el" href="group___p_i_o.html#gafca6496338c7821c25bd946055328197">pio_sample_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a9b9c8e590392068724f06fee015ecbe7">mask</a></td></tr>
<tr class="memdesc:a9b9c8e590392068724f06fee015ecbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each bit set in the mask will be set to <em>mode</em> using I_PIO_SET_PINMODE. <br /></td></tr>
<tr class="separator:a9b9c8e590392068724f06fee015ecbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04a5b4e29cc393860ac64cdafc7b011"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af04a5b4e29cc393860ac64cdafc7b011">flags</a></td></tr>
<tr class="separator:af04a5b4e29cc393860ac64cdafc7b011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41998e5e873977308f91e61ed81e4811"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41998e5e873977308f91e61ed81e4811"></a>
<a class="el" href="group___p_w_m.html#gaa86e40d0d6ad1ae2b4c27cdddf5e2bd6">pwm_duty_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a41998e5e873977308f91e61ed81e4811">top</a></td></tr>
<tr class="memdesc:a41998e5e873977308f91e61ed81e4811"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top value of the PWM counter. <br /></td></tr>
<tr class="separator:a41998e5e873977308f91e61ed81e4811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797270ad0c1a6fd4cf575ecf8baf1c35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a797270ad0c1a6fd4cf575ecf8baf1c35"></a>
<a class="el" href="group___p_w_m.html#gaa86e40d0d6ad1ae2b4c27cdddf5e2bd6">pwm_duty_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a797270ad0c1a6fd4cf575ecf8baf1c35">duty</a></td></tr>
<tr class="memdesc:a797270ad0c1a6fd4cf575ecf8baf1c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The duty cycle. <br /></td></tr>
<tr class="separator:a797270ad0c1a6fd4cf575ecf8baf1c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b80511827be3370d65c9f77bb4b91b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b80511827be3370d65c9f77bb4b91b6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a7b80511827be3370d65c9f77bb4b91b6">max_pos</a></td></tr>
<tr class="memdesc:a7b80511827be3370d65c9f77bb4b91b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum position (QEI rolls over at this point) <br /></td></tr>
<tr class="separator:a7b80511827be3370d65c9f77bb4b91b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eda8db210134bfc5aa1eb7b9b110248"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eda8db210134bfc5aa1eb7b9b110248"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a0eda8db210134bfc5aa1eb7b9b110248">velocity_comp</a></td></tr>
<tr class="memdesc:a0eda8db210134bfc5aa1eb7b9b110248"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Velocity compare value. <br /></td></tr>
<tr class="separator:a0eda8db210134bfc5aa1eb7b9b110248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2506139a032ccdb569389a0efc01421"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2506139a032ccdb569389a0efc01421"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ae2506139a032ccdb569389a0efc01421">filter</a></td></tr>
<tr class="memdesc:ae2506139a032ccdb569389a0efc01421"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filter coefficient (0 to disable) <br /></td></tr>
<tr class="separator:ae2506139a032ccdb569389a0efc01421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a89571a431c71535be14e83021777dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a89571a431c71535be14e83021777dd"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a5a89571a431c71535be14e83021777dd">vfreq</a></td></tr>
<tr class="memdesc:a5a89571a431c71535be14e83021777dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The frequency at which to update the velocity in Hz. <br /></td></tr>
<tr class="separator:a5a89571a431c71535be14e83021777dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef7f44e6452d044b69624380983af69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ef7f44e6452d044b69624380983af69"></a>
struct link_tm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a1ef7f44e6452d044b69624380983af69">time</a></td></tr>
<tr class="memdesc:a1ef7f44e6452d044b69624380983af69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time (compatible with struct tm) used with set/get. <br /></td></tr>
<tr class="separator:a1ef7f44e6452d044b69624380983af69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fadf173c7afd80718a224ad13746c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46fadf173c7afd80718a224ad13746c5"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a46fadf173c7afd80718a224ad13746c5">useconds</a></td></tr>
<tr class="memdesc:a46fadf173c7afd80718a224ad13746c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Microseconds used with set/get. <br /></td></tr>
<tr class="separator:a46fadf173c7afd80718a224ad13746c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2093b079348133dcd617ab91e1ce2dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2093b079348133dcd617ab91e1ce2dc"></a>
<a class="el" href="group___r_t_c.html#ga53e396e6de3003cf6a1c0009842afe4a">rtc_time_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aa2093b079348133dcd617ab91e1ce2dc">time</a></td></tr>
<tr class="memdesc:aa2093b079348133dcd617ab91e1ce2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time for the alarm. <br /></td></tr>
<tr class="separator:aa2093b079348133dcd617ab91e1ce2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93dd83386d3deb9985d9f5a0d20d969c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a93dd83386d3deb9985d9f5a0d20d969c">clock</a></td></tr>
<tr class="separator:a93dd83386d3deb9985d9f5a0d20d969c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c337647bd479d41939da0c7d3dd758"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6c337647bd479d41939da0c7d3dd758"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af6c337647bd479d41939da0c7d3dd758">master</a></td></tr>
<tr class="memdesc:af6c337647bd479d41939da0c7d3dd758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be set to master (SPI_ATTR_MASTER) <br /></td></tr>
<tr class="separator:af6c337647bd479d41939da0c7d3dd758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8578cb1b50b4787a691f338c06a1a87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8578cb1b50b4787a691f338c06a1a87"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ab8578cb1b50b4787a691f338c06a1a87">version</a> [8]</td></tr>
<tr class="memdesc:ab8578cb1b50b4787a691f338c06a1a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OS (kernel) Version. <br /></td></tr>
<tr class="separator:ab8578cb1b50b4787a691f338c06a1a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84d2a92981fd5efa228ce679d6c2775"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad84d2a92981fd5efa228ce679d6c2775"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ad84d2a92981fd5efa228ce679d6c2775">sys_version</a> [8]</td></tr>
<tr class="memdesc:ad84d2a92981fd5efa228ce679d6c2775"><td class="mdescLeft">&#160;</td><td class="mdescRight">The System (board) Version. <br /></td></tr>
<tr class="separator:ad84d2a92981fd5efa228ce679d6c2775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b34300e4928d5bd4416c4e63bbdc763"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b34300e4928d5bd4416c4e63bbdc763"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a6b34300e4928d5bd4416c4e63bbdc763">arch</a> [8]</td></tr>
<tr class="memdesc:a6b34300e4928d5bd4416c4e63bbdc763"><td class="mdescLeft">&#160;</td><td class="mdescRight">The target architecture (lpc17xx, lpc13xx, etc) <br /></td></tr>
<tr class="separator:a6b34300e4928d5bd4416c4e63bbdc763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682f56810312be2db1e1aae0693bdf65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a682f56810312be2db1e1aae0693bdf65"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a682f56810312be2db1e1aae0693bdf65">signature</a></td></tr>
<tr class="memdesc:a682f56810312be2db1e1aae0693bdf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ths OS library signature used to ensure proper build system is used for applications. <br /></td></tr>
<tr class="separator:a682f56810312be2db1e1aae0693bdf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849342478d949b494a0ce39e9dc5b490"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a849342478d949b494a0ce39e9dc5b490"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a849342478d949b494a0ce39e9dc5b490">security</a></td></tr>
<tr class="memdesc:a849342478d949b494a0ce39e9dc5b490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Security flags (see sys_security_flags_t) <br /></td></tr>
<tr class="separator:a849342478d949b494a0ce39e9dc5b490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7360ee04f48e55992ddf800b974c044b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7360ee04f48e55992ddf800b974c044b"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a7360ee04f48e55992ddf800b974c044b">cpu_freq</a></td></tr>
<tr class="memdesc:a7360ee04f48e55992ddf800b974c044b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CPU clock frequency. <br /></td></tr>
<tr class="separator:a7360ee04f48e55992ddf800b974c044b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefccc865666962d4caeacf1d3e3e080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abefccc865666962d4caeacf1d3e3e080"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#abefccc865666962d4caeacf1d3e3e080">sys_mem_size</a></td></tr>
<tr class="memdesc:abefccc865666962d4caeacf1d3e3e080"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes in RAM shared across OS and other processes. <br /></td></tr>
<tr class="separator:abefccc865666962d4caeacf1d3e3e080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c26cd31c23a816736b396a12da78ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98c26cd31c23a816736b396a12da78ac"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a98c26cd31c23a816736b396a12da78ac">stdout_name</a> [LINK_NAME_MAX]</td></tr>
<tr class="memdesc:a98c26cd31c23a816736b396a12da78ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for the standard output. <br /></td></tr>
<tr class="separator:a98c26cd31c23a816736b396a12da78ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ecebc9b1c2fb8971cc0eb41679c237"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9ecebc9b1c2fb8971cc0eb41679c237"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ae9ecebc9b1c2fb8971cc0eb41679c237">stdin_name</a> [LINK_NAME_MAX]</td></tr>
<tr class="memdesc:ae9ecebc9b1c2fb8971cc0eb41679c237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for the standard output. <br /></td></tr>
<tr class="separator:ae9ecebc9b1c2fb8971cc0eb41679c237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b19b595a20036905edc4a31c2fa4e1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b19b595a20036905edc4a31c2fa4e1c"></a>
<a class="el" href="structsn__t.html">sn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a5b19b595a20036905edc4a31c2fa4e1c">serial</a></td></tr>
<tr class="memdesc:a5b19b595a20036905edc4a31c2fa4e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device Serial number. <br /></td></tr>
<tr class="separator:a5b19b595a20036905edc4a31c2fa4e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524b9680d0662224ec454f9449847798"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a524b9680d0662224ec454f9449847798"></a>
u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a524b9680d0662224ec454f9449847798">timer</a></td></tr>
<tr class="memdesc:a524b9680d0662224ec454f9449847798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer used for tracking task CPU usage. <br /></td></tr>
<tr class="separator:a524b9680d0662224ec454f9449847798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070596f5412e3ddfcef406d651723cfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a070596f5412e3ddfcef406d651723cfe"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a070596f5412e3ddfcef406d651723cfe">id</a></td></tr>
<tr class="memdesc:a070596f5412e3ddfcef406d651723cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id (PID or pthread id) to send the signal to. <br /></td></tr>
<tr class="separator:a070596f5412e3ddfcef406d651723cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d37f3c3947c9b75988279ef273547c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9d37f3c3947c9b75988279ef273547c"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af9d37f3c3947c9b75988279ef273547c">si_signo</a></td></tr>
<tr class="memdesc:af9d37f3c3947c9b75988279ef273547c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signal to send (SIGKILL or LINK_SIGKILL for example) <br /></td></tr>
<tr class="separator:af9d37f3c3947c9b75988279ef273547c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799fee3052ca74fe25c3b86bfa9d3e8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a799fee3052ca74fe25c3b86bfa9d3e8a"></a>
i32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a799fee3052ca74fe25c3b86bfa9d3e8a">si_sigcode</a></td></tr>
<tr class="memdesc:a799fee3052ca74fe25c3b86bfa9d3e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signal code (SI_USER or LINK_SI_USER for example) <br /></td></tr>
<tr class="separator:a799fee3052ca74fe25c3b86bfa9d3e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac29a149d470115b6ecbfa296a080b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abac29a149d470115b6ecbfa296a080b4"></a>
i32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#abac29a149d470115b6ecbfa296a080b4">si_sigvalue</a></td></tr>
<tr class="memdesc:abac29a149d470115b6ecbfa296a080b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signal value (not used by default handlers) <br /></td></tr>
<tr class="separator:abac29a149d470115b6ecbfa296a080b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe917710fc091fb98f2866af39b3a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cfe917710fc091fb98f2866af39b3a9"></a>
i32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a7cfe917710fc091fb98f2866af39b3a9">pid</a></td></tr>
<tr class="memdesc:a7cfe917710fc091fb98f2866af39b3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process ID (written by driver; -1 is process is not running) <br /></td></tr>
<tr class="separator:a7cfe917710fc091fb98f2866af39b3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3516ebdb5815a66f8f5435a1384807"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e3516ebdb5815a66f8f5435a1384807"></a>
i32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a2e3516ebdb5815a66f8f5435a1384807">pthread_id</a></td></tr>
<tr class="memdesc:a2e3516ebdb5815a66f8f5435a1384807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread ID of primary thread in process (written by driver; -1 if process is not running) <br /></td></tr>
<tr class="separator:a2e3516ebdb5815a66f8f5435a1384807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11c6781c531dc737755638d962bf148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae11c6781c531dc737755638d962bf148"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ae11c6781c531dc737755638d962bf148">key</a> [32]</td></tr>
<tr class="memdesc:ae11c6781c531dc737755638d962bf148"><td class="mdescLeft">&#160;</td><td class="mdescRight">The password used to unlock the device. <br /></td></tr>
<tr class="separator:ae11c6781c531dc737755638d962bf148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff90ad15bb5b04b3ae0e1a21ebacf084"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff90ad15bb5b04b3ae0e1a21ebacf084"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aff90ad15bb5b04b3ae0e1a21ebacf084">channel</a></td></tr>
<tr class="memdesc:aff90ad15bb5b04b3ae0e1a21ebacf084"><td class="mdescLeft">&#160;</td><td class="mdescRight">the channel (from 0 to 4) <br /></td></tr>
<tr class="separator:aff90ad15bb5b04b3ae0e1a21ebacf084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d62b5664bdb44c976a0817cadbdfe9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04d62b5664bdb44c976a0817cadbdfe9"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a04d62b5664bdb44c976a0817cadbdfe9">on</a></td></tr>
<tr class="memdesc:a04d62b5664bdb44c976a0817cadbdfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-zero to turn the LED on (zero to turn it off) <br /></td></tr>
<tr class="separator:a04d62b5664bdb44c976a0817cadbdfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3c98a9c6ba68996d794e11bf2c2f5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a3c98a9c6ba68996d794e11bf2c2f5f"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a9a3c98a9c6ba68996d794e11bf2c2f5f">channel</a></td></tr>
<tr class="memdesc:a9a3c98a9c6ba68996d794e11bf2c2f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OC or IC channel. <br /></td></tr>
<tr class="separator:a9a3c98a9c6ba68996d794e11bf2c2f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ac6b86b4902a9d0962f313d4abc8bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66ac6b86b4902a9d0962f313d4abc8bf"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a66ac6b86b4902a9d0962f313d4abc8bf">value</a></td></tr>
<tr class="memdesc:a66ac6b86b4902a9d0962f313d4abc8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value to read or write. <br /></td></tr>
<tr class="separator:a66ac6b86b4902a9d0962f313d4abc8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3333cec4709567ac2787872ab7c6e5d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3333cec4709567ac2787872ab7c6e5d9"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a3333cec4709567ac2787872ab7c6e5d9">clksrc</a></td></tr>
<tr class="memdesc:a3333cec4709567ac2787872ab7c6e5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The clock source (see <a class="el" href="group___t_m_r.html#ga752e581dd80394311e122634680ece35">tmr_clksrc_t</a>) <br /></td></tr>
<tr class="separator:a3333cec4709567ac2787872ab7c6e5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08b585436d5e15fb5bd62bf1fbd89b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af08b585436d5e15fb5bd62bf1fbd89b1"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af08b585436d5e15fb5bd62bf1fbd89b1">counter_mode</a></td></tr>
<tr class="memdesc:af08b585436d5e15fb5bd62bf1fbd89b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated. <br /></td></tr>
<tr class="separator:af08b585436d5e15fb5bd62bf1fbd89b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c5cf61d2cd003fe4bdf5941ac307af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44c5cf61d2cd003fe4bdf5941ac307af"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a44c5cf61d2cd003fe4bdf5941ac307af">enabled_oc_chans</a></td></tr>
<tr class="memdesc:a44c5cf61d2cd003fe4bdf5941ac307af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mask of enabled output compare channels. Enabled channels that do not exist are ignored. These are only set if the output compare units will use GPIO. <br /></td></tr>
<tr class="separator:a44c5cf61d2cd003fe4bdf5941ac307af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae043ae0908b62e9d60dcf635b23572e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae043ae0908b62e9d60dcf635b23572e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aae043ae0908b62e9d60dcf635b23572e">enabled_ic_chans</a></td></tr>
<tr class="memdesc:aae043ae0908b62e9d60dcf635b23572e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mask of enabled input capture channels. Enabled channels that do not exist are ignored. These are only set if the input capture units will use GPIO. <br /></td></tr>
<tr class="separator:aae043ae0908b62e9d60dcf635b23572e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbe89900d95503437624be5426bab00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedbe89900d95503437624be5426bab00"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#aedbe89900d95503437624be5426bab00">start</a></td></tr>
<tr class="memdesc:aedbe89900d95503437624be5426bab00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of start bits. <br /></td></tr>
<tr class="separator:aedbe89900d95503437624be5426bab00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1320bf8ac3efce34c75a875a62cc202d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1320bf8ac3efce34c75a875a62cc202d"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a1320bf8ac3efce34c75a875a62cc202d">stop</a></td></tr>
<tr class="memdesc:a1320bf8ac3efce34c75a875a62cc202d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of stop bits. <br /></td></tr>
<tr class="separator:a1320bf8ac3efce34c75a875a62cc202d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922d09982a771daba08fe9cc1f8a6864"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a922d09982a771daba08fe9cc1f8a6864"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a922d09982a771daba08fe9cc1f8a6864">parity</a></td></tr>
<tr class="memdesc:a922d09982a771daba08fe9cc1f8a6864"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of parity. <br /></td></tr>
<tr class="separator:a922d09982a771daba08fe9cc1f8a6864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281123ceac502c0e519d1234828f512b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a281123ceac502c0e519d1234828f512b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a281123ceac502c0e519d1234828f512b">baudrate</a></td></tr>
<tr class="memdesc:a281123ceac502c0e519d1234828f512b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UART baudrate. <br /></td></tr>
<tr class="separator:a281123ceac502c0e519d1234828f512b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb6c6f588ec3a8e834f434ec250d0e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb6c6f588ec3a8e834f434ec250d0e0"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a8fb6c6f588ec3a8e834f434ec250d0e0">width</a></td></tr>
<tr class="memdesc:a8fb6c6f588ec3a8e834f434ec250d0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The character width. <br /></td></tr>
<tr class="separator:a8fb6c6f588ec3a8e834f434ec250d0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7553632b14aabb7fa0fcb833f67b255c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7553632b14aabb7fa0fcb833f67b255c"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a7553632b14aabb7fa0fcb833f67b255c">mode</a></td></tr>
<tr class="memdesc:a7553632b14aabb7fa0fcb833f67b255c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mode see <a class="el" href="group___u_s_b.html#ga578dcf8d54f14603f1fb0b0b1ce56713">usb_attr_mode_t</a>. <br /></td></tr>
<tr class="separator:a7553632b14aabb7fa0fcb833f67b255c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7239647d0cd093027af120b43b67427"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7239647d0cd093027af120b43b67427"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af7239647d0cd093027af120b43b67427">crystal_freq</a></td></tr>
<tr class="memdesc:af7239647d0cd093027af120b43b67427"><td class="mdescLeft">&#160;</td><td class="mdescRight">The crystal oscillator frequency. <br /></td></tr>
<tr class="separator:af7239647d0cd093027af120b43b67427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687278a0ebb6dd55d596a3ef17fa0a7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a687278a0ebb6dd55d596a3ef17fa0a7f"></a>
<a class="el" href="group___d_e_v_i_c_e.html#gab8bf14f84f07e036582fecb002c15b54">device_spi_cfg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a687278a0ebb6dd55d596a3ef17fa0a7f">spi</a></td></tr>
<tr class="memdesc:a687278a0ebb6dd55d596a3ef17fa0a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration for devices that are connected via SPI bus. <br /></td></tr>
<tr class="separator:a687278a0ebb6dd55d596a3ef17fa0a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc66574314f3952c5ddf0e11d1996eb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc66574314f3952c5ddf0e11d1996eb0"></a>
<a class="el" href="structdevice__pwm__cfg__t.html">device_pwm_cfg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#afc66574314f3952c5ddf0e11d1996eb0">pwm</a></td></tr>
<tr class="memdesc:afc66574314f3952c5ddf0e11d1996eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration for devices connected via PWM. <br /></td></tr>
<tr class="separator:afc66574314f3952c5ddf0e11d1996eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7735600a63abec810c4f693bddc8d7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7735600a63abec810c4f693bddc8d7a"></a>
<a class="el" href="group___d_e_v_i_c_e.html#ga25ccd8553b14de0869926409812304a5">device_adc_cfg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#ad7735600a63abec810c4f693bddc8d7a">adc</a></td></tr>
<tr class="memdesc:ad7735600a63abec810c4f693bddc8d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration for devices connected to ADC pins. <br /></td></tr>
<tr class="separator:ad7735600a63abec810c4f693bddc8d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b301ce0130abec907ef0c68300ae93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43b301ce0130abec907ef0c68300ae93"></a>
<a class="el" href="group___d_e_v_i_c_e.html#gaddf04a89642799f8f00892833dc2b4d2">device_uart_cfg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a43b301ce0130abec907ef0c68300ae93">uart</a></td></tr>
<tr class="memdesc:a43b301ce0130abec907ef0c68300ae93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration for devices connected to UART pins. <br /></td></tr>
<tr class="separator:a43b301ce0130abec907ef0c68300ae93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dc228161b48108bbace2b52b2b37b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58dc228161b48108bbace2b52b2b37b7"></a>
<a class="el" href="group___d_e_v_i_c_e.html#ga6d4890d54943d18a1a7a98f00088085d">device_i2c_cfg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a58dc228161b48108bbace2b52b2b37b7">i2c</a></td></tr>
<tr class="memdesc:a58dc228161b48108bbace2b52b2b37b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration for devices connected via I2C bus. <br /></td></tr>
<tr class="separator:a58dc228161b48108bbace2b52b2b37b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b618127447fe744defb999f6b6a0353"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b618127447fe744defb999f6b6a0353"></a>
<a class="el" href="group___p_i_o.html#gaf8578727d6d1ca42e649beec21752b0a">pio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a3b618127447fe744defb999f6b6a0353">pio</a> [4]</td></tr>
<tr class="memdesc:a3b618127447fe744defb999f6b6a0353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for generic GPIO devices such as LEDs. <br /></td></tr>
<tr class="separator:a3b618127447fe744defb999f6b6a0353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bcc7d06982bd6ca8ab2b70fc6e1a60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27bcc7d06982bd6ca8ab2b70fc6e1a60"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a27bcc7d06982bd6ca8ab2b70fc6e1a60">cbuf</a></td></tr>
<tr class="memdesc:a27bcc7d06982bd6ca8ab2b70fc6e1a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to const void buffer. <br /></td></tr>
<tr class="separator:a27bcc7d06982bd6ca8ab2b70fc6e1a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338ac610884c3c6c4dc279cea0309201"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a338ac610884c3c6c4dc279cea0309201"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a338ac610884c3c6c4dc279cea0309201">buf</a></td></tr>
<tr class="memdesc:a338ac610884c3c6c4dc279cea0309201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to void buffer. <br /></td></tr>
<tr class="separator:a338ac610884c3c6c4dc279cea0309201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c46a97213e30f72897de9a421249e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7c46a97213e30f72897de9a421249e8"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#af7c46a97213e30f72897de9a421249e8">cchbuf</a></td></tr>
<tr class="memdesc:af7c46a97213e30f72897de9a421249e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to const char buffer. <br /></td></tr>
<tr class="separator:af7c46a97213e30f72897de9a421249e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c80a37b6935811daab65145854049b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57c80a37b6935811daab65145854049b"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_c_u___p_a_c_k.html#a57c80a37b6935811daab65145854049b">chbuf</a></td></tr>
<tr class="memdesc:a57c80a37b6935811daab65145854049b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to char buffer. <br /></td></tr>
<tr class="separator:a57c80a37b6935811daab65145854049b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="af2f248c3e0c27d58a8425430427091e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t MCU_PACK::addr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the address of the page</p>
<p>The address to write to </p>

</div>
</div>
<a class="anchor" id="ae28d23864fa60f3af2ad871840ba1970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::addr_width</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The width of the address bus </p>

</div>
</div>
<a class="anchor" id="ae29f4c0bdd78f0c5e23e835689ef60b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t MCU_PACK::bitrate</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The I2C bitrate. </p>

</div>
</div>
<a class="anchor" id="a96a2f773d53cdc5238ad60c32589c415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 MCU_PACK::bitrate</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The SPI bitrate. </p>

</div>
</div>
<a class="anchor" id="a709351c6a480e8102b480fcf150fdfd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::channel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EMC Channel (chip select line) </p>

</div>
</div>
<a class="anchor" id="ab246af8d91abf524ec283d6e5363a657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t MCU_PACK::clock</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum clock rate </p>

</div>
</div>
<a class="anchor" id="a93dd83386d3deb9985d9f5a0d20d969c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::clock</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The source clock </p>

</div>
</div>
<a class="anchor" id="a486039ac6cb55ec414a703a66a9a7538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::enabled_channels</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enabled channels bit-mask. </p>

</div>
</div>
<a class="anchor" id="af04a5b4e29cc393860ac64cdafc7b011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t MCU_PACK::flags</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attribute flags for configuring the PWM unit </p>

</div>
</div>
<a class="anchor" id="a23b7eeae0a83d14b39385109b87f3578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 MCU_PACK::format</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The SPI output format (SPI_ATTR_FORMAT_SPI, SPI_ATTR_FORMAT_TI or SPI_ATTR_FORMAT_MICROWIRE) </p>

</div>
</div>
<a class="anchor" id="a5fdeb83df08c04b23c15272f641797fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t MCU_PACK::freq</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The target clock frequency when writing and the actual when reading (only applicable to <a class="el" href="group___t_m_r.html#gga752e581dd80394311e122634680ece35a6928b4e5c83b959e37e3920a09123b35">TMR_CLKSRC_CPU</a>)</p>
<p>The PWM timer frequency (target value on write, actual value on read); The period is the "top" member divided by "freq".</p>
<p>MCI clock frequency.</p>
<p>Calibration frequency for setting the pre-scalar </p>

</div>
</div>
<a class="anchor" id="a4b799bbdb1d0699da4d3ee28114d1a08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::mac_addr[8]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the MAC address </p>

</div>
</div>
<a class="anchor" id="ae29a1317fad39261e25287ca2c04dde8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 MCU_PACK::malloc_loc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>malloc base + size </p>

</div>
</div>
<a class="anchor" id="a007389805fd6b8775bf36778eb63e276"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 MCU_PACK::mem_loc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>location of data memory </p>

</div>
</div>
<a class="anchor" id="a23f503ae9705f834143f76d4647af754"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 MCU_PACK::mem_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>size of data memory </p>

</div>
</div>
<a class="anchor" id="a10128eaba82516c54ffe672392ed08ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 MCU_PACK::mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The SPI mode from 0 to 3 inclusive (CPOL:CPHA or SPI_ATTR_MODE0 to SPI_ATTR_MODE3) </p>

</div>
</div>
<a class="anchor" id="a1db29d3536c45e8f321898f125fc54dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t MCU_PACK::mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The QEI mode (see <a class="el" href="group___q_e_i.html#ga0b9ae3fe9d097d35283efa54afad29b4">qei_mode_t</a>)</p>
<p>Mode flags </p>

</div>
</div>
<a class="anchor" id="a2bfe4f3f8c637cbcba6be0513409bf8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t MCU_PACK::mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OR the pio_mode_t.</p>
<p>OR the mci_mode_t. </p>

</div>
</div>
<a class="anchor" id="afdf90380ee3287422f73b0fa6bf8dac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char MCU_PACK::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Written by caller to specify name.</p>
<p>Name of the process associated with the task. </p>

</div>
</div>
<a class="anchor" id="afe8f700c9c19061a85130b8e6eb54409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t MCU_PACK::nbyte</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of bytes to write </p>

</div>
</div>
<a class="anchor" id="a954b1b0e5c94552b4febf2ef9d7063a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t MCU_PACK::overflow</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If non-zero, indicates data received in the buffer was discarded. </p>

</div>
</div>
<a class="anchor" id="aa028043000bdd4d9681a0d89e7774222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::pin_assign</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pin assignment.</p>
<p>The Pin assignment to use (see LPC17XXDEV)</p>
<p>EMC Pin assignment</p>
<p>Always 0 </p>

</div>
</div>
<a class="anchor" id="a2149072dd41f5ccaeb8da8852b857ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 MCU_PACK::pin_assign</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The GPIO configuration to use (see LPC17XXDEV)</p>
<p>The pin assignment to use (see LPC17XXDEV) </p>

</div>
</div>
<a class="anchor" id="a7c6795fa0655d0a550c9632aee512d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::port</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The port number.</p>
<p>EMC port </p>

</div>
</div>
<a class="anchor" id="a074f3623d4ee7584c9631b67ec780ef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t MCU_PACK::size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the size of the page</p>
<p>The size of the buffer (only size-1 is usable)</p>
<p>Size of the external memory </p>

</div>
</div>
<a class="anchor" id="a3e4922498206deedf973ddc18e8f3d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 MCU_PACK::stack_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>location of stack pointer </p>

</div>
</div>
<a class="anchor" id="aeeb93a3edf045975a50a95b4a0060468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::wait_output_enable</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clock delay from chip select to output enable </p>

</div>
</div>
<a class="anchor" id="aba89b554fe49fd80e70b88138c554c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::wait_page</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of wait states for async page mode read </p>

</div>
</div>
<a class="anchor" id="a73f2f813a5c964bc286615f1db7268dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::wait_rd</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read mode delay </p>

</div>
</div>
<a class="anchor" id="a91a3775345eca1f709956965ad3ca62e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::wait_turn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn around cycles </p>

</div>
</div>
<a class="anchor" id="a62e48f6059859b58c073348d7a47c9ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::wait_wr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write mode delay (SRAM) </p>

</div>
</div>
<a class="anchor" id="a503ac64fde9d1ca872ec66d88450f704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCU_PACK::wait_write_enable</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clock delay from chip select to write enable </p>

</div>
</div>
<a class="anchor" id="aafff78771d82f6e3448de9037a19bf1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 MCU_PACK::width</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The transfer width.</p>
<p>The width of a UART word. </p>

</div>
</div>
</div><!-- contents -->
